using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace UniNativeLinq
{
    public unsafe readonly struct
        SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>
        : IRefEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>.Enumerator, TSource>
        where TSource : unmanaged
        where TFirstEnumerable : struct, IRefEnumerable<TFirstEnumerator, TSource>
        where TFirstEnumerator : struct, IRefEnumerator<TSource>
        where TSecondEnumerable : struct, IRefEnumerable<TSecondEnumerator, TSource>
        where TSecondEnumerator : struct, IRefEnumerator<TSource>
        where TSetOperation : struct, ISetOperation<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource>
    {
        private readonly TFirstEnumerable firstEnumerable;
        private readonly TSecondEnumerable secondEnumerable;
        private readonly Allocator alloc;

        private readonly TSetOperation setOperation;

        public SetOperationEnumerable(in TFirstEnumerable firstEnumerable, in TSecondEnumerable secondEnumerable, TSetOperation setOperation, Allocator alloc)
        {
            this.firstEnumerable = firstEnumerable;
            this.secondEnumerable = secondEnumerable;
            this.setOperation = setOperation;
            this.alloc = alloc;
        }

        public struct Enumerator : IRefEnumerator<TSource>
        {
            private NativeEnumerable<TSource>.Enumerator mergedEnumerator;
            private readonly Allocator allocator;

            public Enumerator(in TFirstEnumerable firstEnumerable, in TSecondEnumerable secondEnumerable, TSetOperation setOperation, Allocator allocator)
            {
                this.allocator = allocator;
                mergedEnumerator = setOperation.Calc(ref Unsafe.AsRef(firstEnumerable), ref Unsafe.AsRef(secondEnumerable), allocator).GetEnumerator();
            }

            public bool MoveNext() => mergedEnumerator.MoveNext();
            public void Reset() => throw new InvalidOperationException();
            public readonly ref TSource Current => ref mergedEnumerator.Current;
            readonly TSource IEnumerator<TSource>.Current => Current;
            readonly object IEnumerator.Current => Current;

            public void Dispose()
            {
                if (mergedEnumerator.Ptr != null && UnsafeUtility.IsValidAllocator(allocator))
                    UnsafeUtility.Free(mergedEnumerator.Ptr, allocator);
                this = default;
            }
        }

        public readonly Enumerator GetEnumerator() => new Enumerator(firstEnumerable, secondEnumerable, setOperation, alloc);

        #region Interface Implementation
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly IEnumerator<TSource> IEnumerable<TSource>.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool CanFastCount() => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Any()
        {
            var enumerator = GetEnumerator();
            if (enumerator.MoveNext())
            {
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Count()
            => (int)LongCount();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly long LongCount()
        {
            var enumerator = GetEnumerator();
            var count = 0L;
            while (enumerator.MoveNext())
                ++count;
            enumerator.Dispose();
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly void CopyTo(TSource* dest)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                *dest++ = enumerator.Current;
            enumerator.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TSource[] ToArray()
        {
            var count = LongCount();
            if (count == 0) return Array.Empty<TSource>();
            var answer = new TSource[count];
            CopyTo((TSource*)Unsafe.AsPointer(ref answer[0]));
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly NativeEnumerable<TSource> ToNativeEnumerable(Allocator allocator)
        {
            var count = LongCount();
            var ptr = UnsafeUtilityEx.Malloc<TSource>(count, allocator);
            CopyTo(ptr);
            return new NativeEnumerable<TSource>(ptr, count);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly NativeArray<TSource> ToNativeArray(Allocator allocator)
        {
            var count = Count();
            if (count == 0) return default;
            var answer = new NativeArray<TSource>(count, allocator, NativeArrayOptions.UninitializedMemory);
            CopyTo(UnsafeUtilityEx.GetPointer(answer));
            return answer;
        }
        #endregion

        #region Enumerable
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly AppendEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource>
            Append(TSource value, Allocator allocator = Allocator.Temp)
            => new AppendEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource>(this, value, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation> AsRefEnumerable() => this;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DefaultIfEmptyEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource>
            DefaultIfEmpty(TSource defaultValue, Allocator allocator = Allocator.Temp)
            => new DefaultIfEmptyEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource>(this, defaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator, TSource, DefaultEqualityComparer<TSource>, DefaultGetHashCodeFunc<TSource>>
            Distinct(Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DefaultEqualityComparer<TSource>, DefaultGetHashCodeFunc<TSource>>(this, default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator, TSource, TEqualityComparer0, TGetHashCodeFunc0>
            Distinct<TEqualityComparer0, TGetHashCodeFunc0>(in TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TEqualityComparer0, TGetHashCodeFunc0>(this, comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TComparer0
            >
            OrderBy<TComparer0>(in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new OrderByEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TComparer0>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByFromFunc<TSource>
            >
            OrderBy(Func<TSource, TSource, int> comparer, Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, OrderByFromFunc<TSource>>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByDescending<TSource, TComparer0>
            >
            OrderByDescending<TComparer0>(in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new OrderByEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, OrderByDescending<TSource, TComparer0>>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByDescending<TSource, OrderByFromFunc<TSource>>
            >
            OrderByDescending(Func<TSource, TSource, int> comparer, Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, OrderByDescending<TSource, OrderByFromFunc<TSource>>>(this, (OrderByFromFunc<TSource>)comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
        (
            NativeEnumerable<TSource> True,
            NativeEnumerable<TSource> False
        )
        ToPartition(Func<TSource, bool> predicate, Allocator allocator = Allocator.Temp)
        {

            var True = new NativeList<TSource>(allocator);
            var False = new NativeList<TSource>(allocator);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate(enumerator.Current))
                    True.Add(enumerator.Current);
                else
                    False.Add(enumerator.Current);
            }
            enumerator.Dispose();
            return (True.AsNativeEnumerable(), False.AsNativeEnumerable());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
        (
            NativeEnumerable<TSource> True,
            NativeEnumerable<TSource> False
        )
        ToPartition<TPredicate0>(in TPredicate0 predicate, Allocator allocator = Allocator.Temp)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
        {

            var True = new NativeList<TSource>(allocator);
            var False = new NativeList<TSource>(allocator);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate.Calc(ref enumerator.Current))
                    True.Add(enumerator.Current);
                else
                    False.Add(enumerator.Current);
            }
            enumerator.Dispose();
            return (True.AsNativeEnumerable(), False.AsNativeEnumerable());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            PrependEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >
            Prepend(TSource value, Allocator allocator = Allocator.Temp)
            => new PrependEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource>(this, value, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ReverseEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource>
            Reverse(Allocator allocator = Allocator.Temp)
            => new ReverseEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource>(this, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectIndexEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TNextResult0, TNextAction0>
            SelectIndex<TNextResult0, TNextAction0>(TNextAction0 action, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            where TNextAction0 : struct, ISelectIndex<TSource, TNextResult0>
            => new SelectIndexEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TNextResult0, TNextAction0>(this, action, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectIndexEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TNextResult0, DelegateFuncToSelectIndexStructOperator<TSource, TNextResult0>>
            SelectIndex<TNextResult0>(Func<TSource, long, TNextResult0> func, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            => new SelectIndexEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TNextResult0, DelegateFuncToSelectIndexStructOperator<TSource, TNextResult0>>(this, func, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TNextResult0, TNextAction0>
            Select<TNextResult0, TNextAction0>(TNextAction0 action, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            where TNextAction0 : struct, IRefAction<TSource, TNextResult0>
            => new SelectEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TNextResult0, TNextAction0>(this, action, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TNextResult0, DelegateFuncToAction<TSource, TNextResult0>>
            Select<TNextResult0>(Func<TSource, TNextResult0> func, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            => new SelectEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TNextResult0, DelegateFuncToAction<TSource, TNextResult0>>(this, func, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                TResultAction
            >
            SelectMany<TResult0, TResultEnumerable0, TResultEnumerator0, TResultAction>(TResultAction action)
            where TResult0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<TResult0>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TResult0>
            where TResultAction : struct, IRefAction<TSource, TResultEnumerable0>
            => new SelectManyEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TResult0, TResultEnumerable0, TResultEnumerator0, TResultAction>(this, action);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                DelegateFuncToAction<TSource, TResultEnumerable0>
            >
            SelectMany<TResult0, TResultEnumerable0, TResultEnumerator0>(Func<TSource, TResultEnumerable0> func)
            where TResult0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<TResult0>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TResult0>
            => new SelectManyEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                DelegateFuncToAction<TSource, TResultEnumerable0>
            >(this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >
            Skip(long count)
            => new SkipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >(this, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipLastEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >
            SkipLast(long count, Allocator allocator = Allocator.Temp)
            => new SkipLastEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >(this, count, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipWhileEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TPredicate0
            >
            SkipWhileIndex<TPredicate0>(in TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new SkipWhileEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >
            Take(long count)
            => new TakeEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >(this, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeWhileEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TPredicate0
            >
            TakeWhileIndex<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new TakeWhileEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeLastEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >
            TakeLast(long count, Allocator allocator = Allocator.Temp)
            => new TakeLastEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource
            >(this, count, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectIndexEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                (TSource, long),
                WithIndex<TSource>
            >
            WithIndex(Allocator allocator = Allocator.Temp)
            => new SelectIndexEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                (TSource, long),
                WithIndex<TSource>
            >(this, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TPredicate0
            >
            Where<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new WhereEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DelegateFuncToStructOperatorFunc<TSource, bool>
            >
            Where(Func<TSource, bool> predicate)
            => new WhereEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DelegateFuncToStructOperatorFunc<TSource, bool>
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereIndexEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TPredicate0
            >
            WhereIndex<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IWhereIndex<TSource>
            => new WhereIndexEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereIndexEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DelegateFuncToWhereIndexStructOperator<TSource>
            >
            WhereIndex(Func<TSource, long, bool> predicate)
            => new WhereIndexEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DelegateFuncToWhereIndexStructOperator<TSource>
            >(this, predicate);
        #endregion

        #region Concat
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TEnumerable1,
                TEnumerator1,
                TSource
            >
            Concat<TEnumerable1, TEnumerator1>
            (in TEnumerable1 second)
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TEnumerable1, TEnumerator1,
                TSource
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, TSource>,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, TSource>.Enumerator,
                TSource
            >
            Concat<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2>
            (in ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, TSource> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable2 : struct, IRefEnumerable<TEnumerator2, TSource>
            where TEnumerator2 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, TSource>,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource
            >
            Concat(NativeArray<TSource> second)
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource
            >(this, NativeEnumerable.AsRefEnumerable(second));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource
            >
            Concat(in NativeEnumerable<TSource> second)
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                AppendEnumerable<TEnumerable1, TEnumerator1, TSource>,
                AppendEnumerable<TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource
            >
            Concat<TEnumerable1, TEnumerator1>
            (in AppendEnumerable<TEnumerable1, TEnumerator1, TSource> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                AppendEnumerable<TEnumerable1, TEnumerator1, TSource>,
                AppendEnumerable<TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource
            >
            Concat(in ArrayEnumerable<TSource> second)
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource
            >
            Concat(in TSource[] second)
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource
            >(this, NativeEnumerable.AsRefEnumerable(second));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource
            >
            Concat<TEnumerable1, TEnumerator1>
            (in DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, TSource> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DistinctEnumerable<TEnumerable1, TEnumerator1, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable1, TEnumerator1, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                TSource
            >
            Concat<TEnumerable1, TEnumerator1, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable1, TEnumerator1, TSource, TEqualityComparer0, TGetHashCodeFunc0> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DistinctEnumerable<TEnumerable1, TEnumerator1, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable1, TEnumerator1, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource
            >
            Concat<TKey0>
            (in Grouping<TKey0, TSource> second)
            where TKey0 : unmanaged
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, TSource, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, TSource, T0Selector, TKeyEqualityComparer0>.Enumerator,
                TSource
            >
            Concat<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0Selector, TKeyEqualityComparer0>
            (in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, TSource, T0Selector, TKeyEqualityComparer0>
            second)
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                TSource>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, TSource, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, TSource, T0Selector, TKeyEqualityComparer0>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer0>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer0>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer0>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer0> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer0>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer0>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RangeRepeatEnumerable<TSource, TAction1>,
                RangeRepeatEnumerable<TSource, TAction1>.Enumerator,
                TSource
            >
            Concat<TAction1>
            (in RangeRepeatEnumerable<TSource, TAction1> second)
            where TAction1 : struct, IRangeRepeat<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RangeRepeatEnumerable<TSource, TAction1>,
                RangeRepeatEnumerable<TSource, TAction1>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource
            >
            Concat
            (in RingBuffer<TSource> second)
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1>,
                SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1>.Enumerator,
                TSource
            >
            Concat<TEnumerable1, TEnumerator1, TPrevSource1, TAction1>
            (in SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1> second)
            where TEnumerator1 : struct, IRefEnumerator<TPrevSource1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TPrevSource1>
            where TAction1 : struct, IRefAction<TPrevSource1, TSource>
            where TPrevSource1 : unmanaged
            => new ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1>,
                    SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1>.Enumerator,
                    TSource>
                (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1>,
                SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1>.Enumerator,
                TSource
            >
            Concat<TEnumerable1, TEnumerator1, TPrevSource1, TAction1>
            (in SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1> second)
            where TEnumerator1 : struct, IRefEnumerator<TPrevSource1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TPrevSource1>
            where TAction1 : struct, ISelectIndex<TPrevSource1, TSource>
            where TPrevSource1 : unmanaged
            => new ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1>,
                    SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, TSource, TAction1>.Enumerator,
                    TSource>
                (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, TSource, TResultEnumerable0, TResultEnumerator0, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, TSource, TResultEnumerable0, TResultEnumerator0, TAction0>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0, TPrevSource0, TResultEnumerable0, TResultEnumerator0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, TSource, TResultEnumerable0, TResultEnumerator0, TAction0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevSource0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<TSource>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TSource>
            where TAction0 : struct, IRefAction<TPrevSource0, TResultEnumerable0>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, TSource, TResultEnumerable0, TResultEnumerator0, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, TSource, TResultEnumerable0, TResultEnumerator0, TAction0>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TEnumerator0,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0>(in SkipEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TEnumerator0,
                TSource
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0>(in TakeEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TEnumerator0,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TEnumerator0,
                TSource
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0>(in SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0>(in TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                UnrolledLinkedList<TSource>,
                UnrolledLinkedList<TSource>.Enumerator,
                TSource
            >
            Concat(in UnrolledLinkedList<TSource> second)
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                UnrolledLinkedList<TSource>,
                UnrolledLinkedList<TSource>.Enumerator,
                TSource
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource
            >
            Concat<TPrevEnumerable0, TPrevEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TSource, TPredicate0> second)
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TSource>
            where TPrevEnumerator0 : struct, IRefEnumerator<TSource>
            where TPredicate0 : struct, IWhereIndex<TSource>
            => new ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TSource, TPredicate0>, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TSource, TPredicate0>.Enumerator, TSource>(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                TSource
            >
            Concat<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0> second)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => new ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator, TSource>(this, second);
        #endregion

        #region Except
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    TSource,
                    TComparer0
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer0>
            (in TEnumerable0 second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TEnumerable0, TEnumerator0, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TEnumerable0, TEnumerator0, TSource, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, TSource>, AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, TSource>, AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in NativeEnumerable<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, NativeEnumerable<TSource>, NativeEnumerable<TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, NativeEnumerable<TSource>, NativeEnumerable<TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0>
            (NativeArray<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, NativeEnumerable<TSource>, NativeEnumerable<TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, NativeEnumerable<TSource>, NativeEnumerable<TSource>.Enumerator, TSource, TComparer0>>
                (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in ArrayEnumerable<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ArrayEnumerable<TSource>, ArrayEnumerable<TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ArrayEnumerable<TSource>, ArrayEnumerable<TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0>
            (TSource[] second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ArrayEnumerable<TSource>, ArrayEnumerable<TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ArrayEnumerable<TSource>, ArrayEnumerable<TSource>.Enumerator, TSource, TComparer0>>
            (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TKey0, TComparer0>
            (in Grouping<TKey0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                TSource>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >(this, second, new ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >(comparer), allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer1 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, TSource>, PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, TSource>, PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RangeRepeatEnumerable<TSource, TAction0>,
                RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TAction0>
            (in RangeRepeatEnumerable<TSource, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TAction0 : struct, IRangeRepeat<TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, RangeRepeatEnumerable<TSource, TAction0>, RangeRepeatEnumerable<TSource, TAction0>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, RangeRepeatEnumerable<TSource, TAction0>, RangeRepeatEnumerable<TSource, TAction0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>, ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>, ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in RingBuffer<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TEnumerator0,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TEnumerator0,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TEnumerator0,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TEnumerator0,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                UnrolledLinkedList<TSource>,
                UnrolledLinkedList<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in UnrolledLinkedList<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                UnrolledLinkedList<TSource>,
                UnrolledLinkedList<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator, TSource, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IWhereIndex<TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator, TSource, ExceptOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);
        #endregion

        #region GroupJoin
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    TEnumerable0,
                    TEnumerator0,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    ArrayEnumerable<T0>,
                    ArrayEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    ArrayEnumerable<T0>,
                    ArrayEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                TKey1,
                T1,
                T0Selector,
                TEqualityComparer0
            >(in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            GroupJoin<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<TSource, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct,
            IRefFunc<TSource,
                WhereIndexEnumerable<
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    GroupJoinPredicate<T0, TKey1, TKeyEqualityComparer1>
                    >,
                T1>
            =>
            new GroupJoinEnumerable
            <
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable
            <
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            GroupJoin<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<TSource, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct,
            IRefFunc<TSource,
                WhereIndexEnumerable<
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    GroupJoinPredicate<T0, TKey1, TKeyEqualityComparer1>
                    >,
                T1>
            =>
            new GroupJoinEnumerable
            <
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    RangeRepeatEnumerable<T0, TAction0>,
                    RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TAction0 : struct, IRangeRepeat<T0>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, RangeRepeatEnumerable<T0, TAction0>, RangeRepeatEnumerable<T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TSource,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new GroupJoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);
        #endregion

        #region Intersect
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer0>
            (in TEnumerable0 second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TEnumerable0, TEnumerator0, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TEnumerable0, TEnumerator0, TSource, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, TSource>, AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, TSource>, AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in NativeEnumerable<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, NativeEnumerable<TSource>, NativeEnumerable<TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, NativeEnumerable<TSource>, NativeEnumerable<TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (NativeArray<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, NativeEnumerable<TSource>, NativeEnumerable<TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, NativeEnumerable<TSource>, NativeEnumerable<TSource>.Enumerator, TSource, TComparer0>>
                (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in ArrayEnumerable<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ArrayEnumerable<TSource>, ArrayEnumerable<TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ArrayEnumerable<TSource>, ArrayEnumerable<TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (TSource[] second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ArrayEnumerable<TSource>, ArrayEnumerable<TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ArrayEnumerable<TSource>, ArrayEnumerable<TSource>.Enumerator, TSource, TComparer0>>
                (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TKey0, TComparer0>
            (in Grouping<TKey0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                TSource>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer1 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, TSource>, PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, TSource>, PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RangeRepeatEnumerable<TSource, TAction0>,
                RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TAction0>
            (in RangeRepeatEnumerable<TSource, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TAction0 : struct, IRangeRepeat<TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, RangeRepeatEnumerable<TSource, TAction0>, RangeRepeatEnumerable<TSource, TAction0>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, RangeRepeatEnumerable<TSource, TAction0>, RangeRepeatEnumerable<TSource, TAction0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>, ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>, ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in RingBuffer<TSource> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator, TSource, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IWhereIndex<TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => new SetOperationEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator, TSource, IntersectOperation<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator, TSource, TComparer0>>
                (this, second, comparer, allocator);
        #endregion

        #region Join
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TKey1 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<TSource, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct, IRefFunc<TSource, T0, T1>
            =>
            new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<TSource, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct, IRefFunc<TSource, T0, T1>
            =>
            new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, RangeRepeatEnumerable<T0, TAction0>, RangeRepeatEnumerable<T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);
        #endregion

        #region Max
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetMax(out TSource value)
        {
            value = default;
            if (typeof(TSource) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, byte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, sbyte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, short>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, ushort>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, int>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, uint>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, long>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, ulong>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, float>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, double>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, decimal>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TSource Max()
        {
            TSource value;
            if (typeof(TSource) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, byte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, sbyte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, short>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, ushort>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, int>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, uint>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, long>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, ulong>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, float>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, double>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, decimal>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
            INITIALIZE:
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<TSource, decimal?>(ref value);
                if (!max.HasValue) goto INITIALIZE;
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, decimal?>(ref enumerator.Current);
                    if (!current.HasValue || current.Value <= max.Value) continue;
                    max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(byte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(sbyte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(short?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(ushort?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(int?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(uint?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(long?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(ulong?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(float?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(double?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(decimal?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<TSource, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMax<TResult0>(Func<TSource, TResult0> func, out TResult0 value)
            where TResult0 : unmanaged
        {
            value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TResult0 Max<TResult0>(Func<TSource, TResult0> func)
            where TResult0 : unmanaged
        {
            TResult0 value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
        #endregion

        #region MaxByFirst
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, byte> func, out (TSource value, byte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, byte?> func, out (TSource value, byte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, byte> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, byte?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            byte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, sbyte> func, out (TSource value, sbyte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, sbyte?> func, out (TSource value, sbyte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, sbyte> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, sbyte?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            sbyte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, short> func, out (TSource value, short key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, short?> func, out (TSource value, short? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, short> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, short?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            short? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, short?> func)
        {
            var enumerator = GetEnumerator();
            short? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, ushort> func, out (TSource value, ushort key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, ushort?> func, out (TSource value, ushort? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, ushort> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, ushort?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ushort? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, int> func, out (TSource value, int key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, int?> func, out (TSource value, int? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, int> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, int?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            int? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, int?> func)
        {
            var enumerator = GetEnumerator();
            int? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, uint> func, out (TSource value, uint key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, uint?> func, out (TSource value, uint? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, uint> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, uint?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            uint? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, long> func, out (TSource value, long key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, long?> func, out (TSource value, long? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, long> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, long?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            long? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, long?> func)
        {
            var enumerator = GetEnumerator();
            long? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, ulong> func, out (TSource value, ulong key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, ulong?> func, out (TSource value, ulong? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, ulong> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, ulong?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ulong? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, float> func, out (TSource value, float key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, float?> func, out (TSource value, float? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, float> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, float?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            float? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, float?> func)
        {
            var enumerator = GetEnumerator();
            float? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, double> func, out (TSource value, double key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, double?> func, out (TSource value, double? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, double> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, double?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            double? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, double?> func)
        {
            var enumerator = GetEnumerator();
            double? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, decimal> func, out (TSource value, decimal key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, decimal?> func, out (TSource value, decimal? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, decimal> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<TSource, decimal?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            decimal? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByFirst(Func<TSource, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        #endregion

        #region MaxByLast
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, byte> func, out (TSource value, byte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, byte?> func, out (TSource value, byte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, byte> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, byte?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            byte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, sbyte> func, out (TSource value, sbyte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, sbyte?> func, out (TSource value, sbyte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, sbyte> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, sbyte?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            sbyte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, short> func, out (TSource value, short key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, short?> func, out (TSource value, short? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, short> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, short?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            short? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, short?> func)
        {
            var enumerator = GetEnumerator();
            short? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, ushort> func, out (TSource value, ushort key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, ushort?> func, out (TSource value, ushort? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, ushort> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, ushort?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ushort? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, int> func, out (TSource value, int key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, int?> func, out (TSource value, int? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, int> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, int?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            int? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, int?> func)
        {
            var enumerator = GetEnumerator();
            int? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, uint> func, out (TSource value, uint key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, uint?> func, out (TSource value, uint? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, uint> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, uint?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            uint? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, long> func, out (TSource value, long key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, long?> func, out (TSource value, long? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, long> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, long?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            long? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, long?> func)
        {
            var enumerator = GetEnumerator();
            long? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, ulong> func, out (TSource value, ulong key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, ulong?> func, out (TSource value, ulong? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, ulong> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, ulong?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ulong? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, float> func, out (TSource value, float key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, float?> func, out (TSource value, float? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, float> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, float?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            float? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, float?> func)
        {
            var enumerator = GetEnumerator();
            float? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, double> func, out (TSource value, double key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, double?> func, out (TSource value, double? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, double> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, double?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            double? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, double?> func)
        {
            var enumerator = GetEnumerator();
            double? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, decimal> func, out (TSource value, decimal key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, decimal?> func, out (TSource value, decimal? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, decimal> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<TSource, decimal?> func, out TSource max)
        {
            var enumerator = GetEnumerator();
            max = default;
            decimal? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MaxByLast(Func<TSource, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? maxKey;
            TSource maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        #endregion

        #region Min
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetMin(out TSource value)
        {
            value = default;
            if (typeof(TSource) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, byte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, sbyte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, short>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, ushort>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, int>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, uint>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, long>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, ulong>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, float>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, double>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, decimal>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(TSource) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TSource Min()
        {
            TSource value;
            if (typeof(TSource) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, byte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, sbyte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, short>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, ushort>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, int>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, uint>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, long>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, ulong>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, float>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, double>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<TSource, decimal>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
            INITIALIZE:
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<TSource, decimal?>(ref value);
                if (!min.HasValue) goto INITIALIZE;
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, decimal?>(ref enumerator.Current);
                    if (!current.HasValue || current.Value <= min.Value) continue;
                    min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(byte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(sbyte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(short?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(ushort?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(int?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(uint?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(long?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(ulong?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(float?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(double?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(TSource) == typeof(decimal?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<TSource, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<TSource, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMin<TResult0>(Func<TSource, TResult0> func, out TResult0 value)
            where TResult0 : unmanaged
        {
            value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TResult0 Min<TResult0>(Func<TSource, TResult0> func)
            where TResult0 : unmanaged
        {
            TResult0 value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
        #endregion

        #region MinByFirst
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, byte> func, out (TSource value, byte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, byte?> func, out (TSource value, byte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, byte> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, byte?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            byte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, sbyte> func, out (TSource value, sbyte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, sbyte?> func, out (TSource value, sbyte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, sbyte> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, sbyte?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            sbyte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, short> func, out (TSource value, short key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, short?> func, out (TSource value, short? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, short> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, short?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            short? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, short?> func)
        {
            var enumerator = GetEnumerator();
            short? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, ushort> func, out (TSource value, ushort key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, ushort?> func, out (TSource value, ushort? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, ushort> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, ushort?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ushort? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, int> func, out (TSource value, int key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, int?> func, out (TSource value, int? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, int> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, int?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            int? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, int?> func)
        {
            var enumerator = GetEnumerator();
            int? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, uint> func, out (TSource value, uint key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, uint?> func, out (TSource value, uint? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, uint> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, uint?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            uint? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, long> func, out (TSource value, long key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, long?> func, out (TSource value, long? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, long> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, long?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            long? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, long?> func)
        {
            var enumerator = GetEnumerator();
            long? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, ulong> func, out (TSource value, ulong key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, ulong?> func, out (TSource value, ulong? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, ulong> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, ulong?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ulong? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, float> func, out (TSource value, float key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, float?> func, out (TSource value, float? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, float> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, float?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            float? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, float?> func)
        {
            var enumerator = GetEnumerator();
            float? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, double> func, out (TSource value, double key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, double?> func, out (TSource value, double? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, double> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, double?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            double? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, double?> func)
        {
            var enumerator = GetEnumerator();
            double? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, decimal> func, out (TSource value, decimal key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, decimal?> func, out (TSource value, decimal? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, decimal> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<TSource, decimal?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            decimal? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByFirst(Func<TSource, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        #endregion

        #region MinByLast
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, byte> func, out (TSource value, byte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, byte?> func, out (TSource value, byte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, byte> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, byte?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            byte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, sbyte> func, out (TSource value, sbyte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, sbyte?> func, out (TSource value, sbyte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, sbyte> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, sbyte?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            sbyte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, short> func, out (TSource value, short key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, short?> func, out (TSource value, short? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, short> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, short?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            short? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, short?> func)
        {
            var enumerator = GetEnumerator();
            short? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, ushort> func, out (TSource value, ushort key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, ushort?> func, out (TSource value, ushort? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, ushort> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, ushort?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ushort? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, int> func, out (TSource value, int key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, int?> func, out (TSource value, int? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, int> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, int?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            int? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, int?> func)
        {
            var enumerator = GetEnumerator();
            int? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, uint> func, out (TSource value, uint key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, uint?> func, out (TSource value, uint? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, uint> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, uint?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            uint? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, long> func, out (TSource value, long key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, long?> func, out (TSource value, long? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, long> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, long?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            long? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, long?> func)
        {
            var enumerator = GetEnumerator();
            long? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, ulong> func, out (TSource value, ulong key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, ulong?> func, out (TSource value, ulong? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, ulong> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, ulong?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ulong? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, float> func, out (TSource value, float key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, float?> func, out (TSource value, float? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, float> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, float?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            float? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, float?> func)
        {
            var enumerator = GetEnumerator();
            float? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, double> func, out (TSource value, double key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, double?> func, out (TSource value, double? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, double> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, double?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            double? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, double?> func)
        {
            var enumerator = GetEnumerator();
            double? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, decimal> func, out (TSource value, decimal key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, decimal?> func, out (TSource value, decimal? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, decimal> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<TSource, decimal?> func, out TSource min)
        {
            var enumerator = GetEnumerator();
            min = default;
            decimal? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TSource MinByLast(Func<TSource, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? minKey;
            TSource minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        #endregion

        public
            MinMaxByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                MinByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            MinBy<TKey0>(Func<TSource, TKey0> func)
            where TKey0 : unmanaged
            => new MinMaxByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                MinByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            (this, func, default, default);

        public
            MinMaxByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                MaxByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            MaxBy<TKey0>(Func<TSource, TKey0> func)
            where TKey0 : unmanaged
            => new MinMaxByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                MaxByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            (this, func, default, default);

        #region Union
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator, TEnumerable0, TEnumerator0, TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator, TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TEnumerable0 second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TEnumerable0, TEnumerator0, TSource>, ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TEnumerable0, TEnumerator0, TSource>.Enumerator, TSource, TEqualityComparer0, TGetHashCodeFunc0>
                (Concat<TEnumerable0, TEnumerator0>(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, TSource>
                    second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in NativeEnumerable<TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (NativeArray<TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in ArrayEnumerable<TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (TSource[]
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, TGetHashCodeFunc0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TEqualityComparer1, TGetHashCodeFunc1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TEqualityComparer1 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc1 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TKey0>
            (in Grouping<TKey0, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(in second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>,
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                TSource>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>,
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>,
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>,
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TAction0, TEqualityComparer0, TGetHashCodeFunc0>
            (in RangeRepeatEnumerable<TSource, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in RingBuffer<TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TPrevEnumerable0, TPrevEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPrevSource0, TAction0>
            (in SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TPrevEnumerable0, TPrevEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, ISelectIndex<TPrevSource0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, T0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>
            => new DistinctEnumerable<ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator, TSource>, ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator, TSource>.Enumerator, TSource, TEqualityComparer0, TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in UnrolledLinkedList<TSource>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IWhereIndex<TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);
        #endregion

        #region SequenceEqual
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TEnumerable0 second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
        {
            var enumerator0 = GetEnumerator();
            var enumerator1 = second.GetEnumerator();
            while (true)
            {
                var b = enumerator0.MoveNext();
                if (b ^ enumerator1.MoveNext())
                {
                    enumerator0.Dispose();
                    enumerator1.Dispose();
                    return false;
                }
                if (!b)
                {
                    enumerator0.Dispose();
                    enumerator1.Dispose();
                    return true;
                }
                if (!comparer.Calc(ref enumerator0.Current, ref enumerator1.Current)) return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => SequenceEqual<
                TEnumerable0, TEnumerator0,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => SequenceEqual<
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in NativeEnumerable<TSource> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in NativeEnumerable<TSource> second)
            => SequenceEqual<
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in NativeArray<TSource> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TEqualityComparer0
            >(NativeEnumerable.AsRefEnumerable(second), comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in NativeArray<TSource> second)
            => SequenceEqual<
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(NativeEnumerable.AsRefEnumerable(second), default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in ArrayEnumerable<TSource> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in ArrayEnumerable<TSource> second)
            => SequenceEqual<
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (TSource[] second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TEqualityComparer0
            >(NativeEnumerable.AsRefEnumerable(second), comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(TSource[] second)
            => SequenceEqual<
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(NativeEnumerable.AsRefEnumerable(second), default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            => SequenceEqual<
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => SequenceEqual<
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TEqualityComparer1, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TEqualityComparer1 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => SequenceEqual<
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0, TKey0>
            (in Grouping<TKey0, TSource> second, in TEqualityComparer0 comparer)
            where TKey0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TEqualityComparer0
            >
            (second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer1, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc0> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer1 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => SequenceEqual<
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            => SequenceEqual<
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                TSource>
            => SequenceEqual<
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            => SequenceEqual<
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => SequenceEqual<
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => SequenceEqual<
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => SequenceEqual<
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0, TAction0>
            (in RangeRepeatEnumerable<TSource, TAction0> second, in TEqualityComparer0 comparer)
            where TAction0 : struct, IRangeRepeat<TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                RangeRepeatEnumerable<TSource, TAction0>,
                RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TAction0>
            (in RangeRepeatEnumerable<TSource, TAction0> second)
            where TAction0 : struct, IRangeRepeat<TSource>
            => SequenceEqual<

                RangeRepeatEnumerable<TSource, TAction0>,
                RangeRepeatEnumerable<TSource, TAction0>.Enumerator,

                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => SequenceEqual<
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in RingBuffer<TSource> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual
            (in RingBuffer<TSource> second)
            => SequenceEqual<
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, TSource>
            => SequenceEqual<
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, TSource>
            => SequenceEqual<
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<T0, TSource>
            => SequenceEqual<
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<T0, TSource>
            => SequenceEqual<
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, T0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => SequenceEqual<
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => SequenceEqual<
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>
            => SequenceEqual<
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>
            => SequenceEqual<
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TEnumerator0,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => SequenceEqual<
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TEnumerator0,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => SequenceEqual<
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in UnrolledLinkedList<TSource> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => SequenceEqual<
                UnrolledLinkedList<TSource>,
                UnrolledLinkedList<TSource>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => SequenceEqual<
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => SequenceEqual<
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TPredicate0 : struct, IWhereIndex<TSource>
            => SequenceEqual<
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IWhereIndex<TSource>
            => SequenceEqual<
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, T0, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => SequenceEqual<
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => SequenceEqual<
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                DefaultEqualityComparer<TSource>
            >(second, default);
        #endregion

        #region Zip
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TEnumerable0 second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >(this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TResult0, TAction0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TKey0, T0, TResult0, TAction0>
            (in Grouping<TKey0, T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult0, TAction0>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, TAction0 action, TSource firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T2, TResult0>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult0, TAction0>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, TAction0 action, TSource firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T2, TResult0>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction1>,
                RangeRepeatEnumerable<T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0, TAction1>
            (in RangeRepeatEnumerable<T0, TAction1>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRangeRepeat<T0>
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, RangeRepeatEnumerable<T0, TAction1>, RangeRepeatEnumerable<T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0>
            (in RingBuffer<T0>
                second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TAction1>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TAction1>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TEnumerable1, TEnumerator1, TAction1>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0, TResult0, TAction0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0>
            (in UnrolledLinkedList<T0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TSource, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>.Enumerator,
                TResult1,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TResult1, TAction0, TAction1>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>
            second, TAction0 action, TSource firstDefaultValue = default, TResult1 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TAction1 : struct, IRefAction<T0, T1, TResult1>
            where TResult0 : unmanaged
            where TResult1 : unmanaged
            where TAction0 : struct, IRefAction<TSource, TResult1, TResult0>
            => new ZipEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>.Enumerator, TResult1, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);
        #endregion

        #region Zip ValueTuple
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TEnumerable0 second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TKey0, T0>
            (in Grouping<TKey0, T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (TSource, T2),
                ZipValueTuple<TSource, T2>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, TSource firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (TSource, T2),
                ZipValueTuple<TSource, T2>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (TSource, T2),
                ZipValueTuple<TSource, T2>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, TSource firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (TSource, T2),
                ZipValueTuple<TSource, T2>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >(this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<T0, TAction0>
            (in RangeRepeatEnumerable<T0, TAction0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<T0>
            (in RingBuffer<T0>
                second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<T0>
            (in UnrolledLinkedList<T0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (TSource, T0),
                ZipValueTuple<TSource, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                (TSource, TResult0),
                ZipValueTuple<TSource, TResult0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            second, TSource firstDefaultValue = default, TResult0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<T0, T1, TResult0>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                (TSource, TResult0),
                ZipValueTuple<TSource, TResult0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);
        #endregion

        #region Function
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool IsEmpty() => !Any();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Any<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!predicate.Calc(ref enumerator.Current)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Any(Func<TSource, bool> predicate)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!predicate(enumerator.Current)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool All<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate.Calc(ref enumerator.Current)) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool All(Func<TSource, bool> predicate)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate(enumerator.Current)) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly void Aggregate<TAccumulate0, TFunc0>(ref TAccumulate0 seed, TFunc0 func)
            where TFunc0 : struct, IRefAction<TAccumulate0, TSource>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                func.Execute(ref seed, ref enumerator.Current);
            enumerator.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TNextResult0 Aggregate<TAccumulate0, TNextResult0, TFunc0, TResultFunc0>(ref TAccumulate0 seed, TFunc0 func, TResultFunc0 resultFunc)
            where TFunc0 : struct, IRefAction<TAccumulate0, TSource>
            where TResultFunc0 : struct, IRefFunc<TAccumulate0, TNextResult0>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                func.Execute(ref seed, ref enumerator.Current);
            enumerator.Dispose();
            return resultFunc.Calc(ref seed);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TSource Aggregate(Func<TSource, TSource, TSource> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var seed = enumerator.Current;
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return seed;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TAccumulate0 Aggregate<TAccumulate0>(TAccumulate0 seed, Func<TAccumulate0, TSource, TAccumulate0> func)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return seed;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TNextResult0 Aggregate<TAccumulate0, TNextResult0>(TAccumulate0 seed, Func<TAccumulate0, TSource, TAccumulate0> func, Func<TAccumulate0, TNextResult0> resultFunc)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return resultFunc(seed);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(in TSource value) => Contains(in value, EqualityComparer<TSource>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(TSource value) => Contains(in value, EqualityComparer<TSource>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(in TSource value, IEqualityComparer<TSource> comparer)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!comparer.Equals(enumerator.Current, value)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(TSource value, IEqualityComparer<TSource> comparer) => Contains(in value, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains<TComparer0>(ref TSource value, ref TComparer0 comparer)
        where TComparer0 : struct, IRefFunc<TSource, TSource, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!comparer.Calc(ref enumerator.Current, ref value)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains<TComparer0>(TSource value, TComparer0 comparer)
            where TComparer0 : struct, IRefFunc<TSource, TSource, bool>
            => Contains(ref value, ref comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Count(Func<TSource, bool> predicate)
            => (int)LongCount(predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Count<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => (int)LongCount(predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly long LongCount(Func<TSource, bool> predicate)
        {
            var enumerator = GetEnumerator();
            var count = 0L;
            while (enumerator.MoveNext())
                if (predicate(enumerator.Current))
                    ++count;
            enumerator.Dispose();
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly long LongCount<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
        {
            var enumerator = GetEnumerator();
            var count = 0L;
            while (enumerator.MoveNext())
                if (predicate.Calc(ref enumerator.Current))
                    ++count;
            enumerator.Dispose();
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetElementAt(long index, out TSource value)
        {
            if (index < 0)
            {
                value = default;
                return false;
            }
            var enumerator = GetEnumerator();
            for (var i = 0L; i < index; i++)
            {
                if (enumerator.MoveNext()) continue;
                value = default;
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetFirst(out TSource first)
        {
            var enumerator = GetEnumerator();
            if (enumerator.MoveNext())
            {
                first = enumerator.Current;
                enumerator.Dispose();
                return true;
            }
            first = default;
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetLast(out TSource last)
        {
            var enumerator = GetEnumerator();
            last = default;
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            while (enumerator.MoveNext())
                last = enumerator.Current;
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle(out TSource value)
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle<TPredicate0>(out TSource value, TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<TSource, bool>
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                if (!predicate.Calc(ref enumerator.Current)) continue;
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle(out TSource value, Func<TSource, bool> predicate)
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                if (!predicate(enumerator.Current)) continue;
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Dictionary<TKey0, TElement0> ToDictionary<TKey0, TElement0>(Func<TSource, TKey0> keySelector, Func<TSource, TElement0> elementSelector)
        {
            var answer = new Dictionary<TKey0, TElement0>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                ref var current = ref enumerator.Current;
                answer.Add(keySelector(current), elementSelector(current));
            }
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Dictionary<TKey0, TElement0> ToDictionary<TKey0, TElement0, TKey0Func, TElement0Func>(TKey0Func keySelector, TElement0Func elementSelector)
            where TKey0Func : struct, IRefFunc<TSource, TKey0>
            where TElement0Func : struct, IRefFunc<TSource, TElement0>
        {
            var answer = new Dictionary<TKey0, TElement0>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                ref var current = ref enumerator.Current;
                answer.Add(keySelector.Calc(ref current), elementSelector.Calc(ref current));
            }
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly HashSet<TSource> ToHashSet()
        {
            var answer = new HashSet<TSource>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly HashSet<TSource> ToHashSet(IEqualityComparer<TSource> comparer)
        {
            var answer = new HashSet<TSource>(comparer);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly List<TSource> ToList()
        {
            var answer = new List<TSource>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }
        #endregion

        #region Sum
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TSource
            Sum()
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return default;
            }
            if (typeof(TSource) == typeof(byte))
            {
                var sum = Unsafe.As<TSource, byte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, byte>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<byte, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(sbyte))
            {
                var sum = Unsafe.As<TSource, sbyte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, sbyte>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<sbyte, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(short))
            {
                var sum = Unsafe.As<TSource, short>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, short>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<short, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(ushort))
            {
                var sum = Unsafe.As<TSource, ushort>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, ushort>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<ushort, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(int))
            {
                var sum = Unsafe.As<TSource, int>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, int>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<int, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(uint))
            {
                var sum = Unsafe.As<TSource, uint>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, uint>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<uint, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(long))
            {
                var sum = Unsafe.As<TSource, long>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, long>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<long, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(ulong))
            {
                var sum = Unsafe.As<TSource, ulong>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, ulong>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<ulong, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(float))
            {
                var sum = Unsafe.As<TSource, float>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, float>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<float, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(double))
            {
                var sum = Unsafe.As<TSource, double>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, double>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<double, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(decimal))
            {
                var sum = Unsafe.As<TSource, decimal>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<TSource, decimal>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<decimal, TSource>(ref sum);
            }
            return default;
        }
        #endregion

        #region Average
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            bool
            TryGetAverage(out TSource value)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                value = default;
                enumerator.Dispose();
                return false;
            }
            var count = 1L;
            if (typeof(TSource) == typeof(byte))
            {
                long sum = Unsafe.As<TSource, byte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, byte>(ref enumerator.Current);
                }
                var val = (byte)(sum / count);
                value = Unsafe.As<byte, TSource>(ref val);
            }
            else if (typeof(TSource) == typeof(sbyte))
            {
                long sum = Unsafe.As<TSource, sbyte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, sbyte>(ref enumerator.Current);
                }
                var val = (sbyte)(sum / count);
                value = Unsafe.As<sbyte, TSource>(ref val);
            }
            else if (typeof(TSource) == typeof(short))
            {
                long sum = Unsafe.As<TSource, short>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, short>(ref enumerator.Current);
                }
                var val = (short)(sum / count);
                value = Unsafe.As<short, TSource>(ref val);
            }
            else if (typeof(TSource) == typeof(ushort))
            {
                long sum = Unsafe.As<TSource, ushort>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, ushort>(ref enumerator.Current);
                }
                var val = (ushort)(sum / count);
                value = Unsafe.As<ushort, TSource>(ref val);
            }
            else if (typeof(TSource) == typeof(int))
            {
                long sum = Unsafe.As<TSource, int>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, int>(ref enumerator.Current);
                }
                var val = (int)(sum / count);
                value = Unsafe.As<int, TSource>(ref val);
            }
            else if (typeof(TSource) == typeof(uint))
            {
                long sum = Unsafe.As<TSource, uint>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, uint>(ref enumerator.Current);
                }
                var val = (uint)(sum / count);
                value = Unsafe.As<uint, TSource>(ref val);
            }
            else if (typeof(TSource) == typeof(long))
            {
                var sum = Unsafe.As<TSource, long>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, long>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<long, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(ulong))
            {
                var sum = Unsafe.As<TSource, ulong>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, ulong>(ref enumerator.Current);
                }
                sum /= (ulong)count;
                value = Unsafe.As<ulong, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(float))
            {
                var sum = Unsafe.As<TSource, float>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, float>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<float, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(double))
            {
                var sum = Unsafe.As<TSource, double>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, double>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<double, TSource>(ref sum);
            }
            else if (typeof(TSource) == typeof(decimal))
            {
                var sum = Unsafe.As<TSource, decimal>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<TSource, decimal>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<decimal, TSource>(ref sum);
            }
            else
            {
                value = enumerator.Current;
            }
            enumerator.Dispose();
            return true;
        }
        #endregion

        #region OrderByDefault
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultOrderByAscending<TSource>
            >
            OrderBy(Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DefaultOrderByAscending<TSource>>(this, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultOrderByDescending<TSource>
            >
            OrderByDescending(Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, TSource, DefaultOrderByDescending<TSource>>(this, default, allocator);
        #endregion

        #region Union Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator, TEnumerable0, TEnumerator0, TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator, TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator, TEnumerable0, TEnumerator0, TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator, TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat<TEnumerable0, TEnumerator0>(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, TSource>
                    second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                    ConcatEnumerable<
                        SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                        Enumerator,
                        AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                        AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                        TSource>,
                    ConcatEnumerable<
                        SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                        Enumerator,
                        AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                        AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                        TSource>.Enumerator,
                    TSource,
                    DefaultEqualityComparer<TSource>,
                    DefaultGetHashCodeFunc<TSource>
                >
                (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union
            (in NativeEnumerable<TSource>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union
            (NativeArray<TSource>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union
            (in ArrayEnumerable<TSource>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union
            (TSource[]
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer1, TGetHashCodeFunc1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer1 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc1 : struct, IRefFunc<TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0, TKey0>
            (in Grouping<TKey0, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TKey0 : unmanaged
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(in second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>,
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                TSource>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>,
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>,
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>,
                ConcatEnumerable<SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator, TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer0 : struct, IRefFunc<TSource, TSource, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TAction0>
            (in RangeRepeatEnumerable<TSource, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union
            (in RingBuffer<TSource>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TAction0>
            (in SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, ISelectIndex<TPrevSource0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource, TSetOperation0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TEnumerator0,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TEnumerator0,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union
            (in UnrolledLinkedList<TSource>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    UnrolledLinkedList<TSource>,
                    UnrolledLinkedList<TSource>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IWhereIndex<TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource>,
                ConcatEnumerable<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource>.Enumerator,
                TSource,
                DefaultEqualityComparer<TSource>,
                DefaultGetHashCodeFunc<TSource>>
            (Concat(second), default, default, allocator);
        #endregion

        #region Intersect Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect
            (in NativeEnumerable<TSource> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
           (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect
            (NativeArray<TSource> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect
            (in ArrayEnumerable<TSource> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect
            (TSource[] second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
           (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TKey0>
            (in Grouping<TKey0, TSource> second, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                TSource>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer1 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RangeRepeatEnumerable<TSource, TAction0>,
                RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TAction0>
            (in RangeRepeatEnumerable<TSource, TAction0> second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RangeRepeatEnumerable<TSource, TAction0>,
                RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect
            (in RingBuffer<TSource> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IWhereIndex<TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                TSource,
                IntersectOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);
        #endregion

        #region Except Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except
            (in NativeEnumerable<TSource> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
           (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except
            (NativeArray<TSource> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                NativeEnumerable<TSource>,
                NativeEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    NativeEnumerable<TSource>,
                    NativeEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except
            (in ArrayEnumerable<TSource> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except
            (TSource[] second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ArrayEnumerable<TSource>,
                ArrayEnumerable<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ArrayEnumerable<TSource>,
                    ArrayEnumerable<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
           (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEnumerator1 : struct, IRefEnumerator<TSource>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, TSource, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TKey0>
            (in Grouping<TKey0, TSource> second, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                Grouping<TKey0, TSource>,
                Grouping<TKey0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    Grouping<TKey0, TSource>,
                    Grouping<TKey0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                TSource>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<TSource, TSource, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<TSource, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, TSource>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, TSource, T0Selector, TEqualityComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TComparer1 : struct, IRefFunc<TSource, TSource, int>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, TSource, TComparer1>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RangeRepeatEnumerable<TSource, TAction0>,
                RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TAction0>
            (in RangeRepeatEnumerable<TSource, TAction0> second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RangeRepeatEnumerable<TSource, TAction0>,
                RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RangeRepeatEnumerable<TSource, TAction0>,
                    RangeRepeatEnumerable<TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, TSource> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except
            (in RingBuffer<TSource> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                RingBuffer<TSource>,
                RingBuffer<TSource>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    RingBuffer<TSource>,
                    RingBuffer<TSource>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IRefFunc<TSource, bool>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<TSource>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TSource>
            where TPredicate0 : struct, IWhereIndex<TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, TSource, TPredicate0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, TSource>
            => new SetOperationEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                TSource,
                ExceptOperation<
                    SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TSource, TAction0>.Enumerator,
                    TSource,
                    DefaultOrderByAscending<TSource>
                >
            >
            (this, second, default, allocator);
        #endregion

        #region Join
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TKey1 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1, TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TEqualityComparer1 : struct, IRefFunc<TKey2, TKey2, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey2, TEqualityComparer1>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<TSource, TKey0>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T1Selector : struct, IRefFunc<TSource, T0, T1>
            =>
            new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey2, TKey2, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<TSource, TKey0>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T1Selector : struct, IRefFunc<TSource, T0, T1>
            =>
            new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<TSource, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<TSource, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);
        #endregion

        #region Join Default Func
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TEnumerable0 inner, in Func<TSource, TKey0> outerKeySelector, in Func<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in NativeEnumerable<T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (NativeArray<T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in ArrayEnumerable<T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (T0[] inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1, TKey0,
                T1
            >
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>
                inner,
                in Func<TSource, TKey0> outerKeySelector,
                in Func<T0, TKey0> innerKeySelector,
                in Func<TSource, T0, T1> resultSelector,
                Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TEqualityComparer1 : struct, IRefFunc<TKey2, TKey2, bool>
            where T2Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey2, TEqualityComparer1>
                    >,
                T0>
            where T1 : unmanaged
            =>
            new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TOuterEnumerable0,
                TOuterEnumerator0,
                TOuterSource0,
                TInnerEnumerable0,
                TInnerEnumerator0,
                TInnerSource0,
                TKey2,
                TOuterKeySelector0,
                TInnerKeySelector0,
                T0,
                T2Selector,
                TKeyEqualityComparer0,
                TKey0,
                T1
            >
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>
                inner,
                in Func<TSource, TKey0> outerKeySelector,
                in Func<T0, TKey0> innerKeySelector,
                in Func<TSource, T0, T1> resultSelector,
                Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey2, TKey2, bool>
            where T2Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            =>
            new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
            >
            (in RingBuffer<T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
            >
            (in UnrolledLinkedList<T0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged



            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<TSource, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<TSource, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged



            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<TSource, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<TSource, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);
        #endregion

        #region Zip Function
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TEnumerable0 second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TResult1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0, TResult1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TKey0, T0, TResult1>
            (in Grouping<TKey0, T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<TSource, T2, TResult1>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, Func<TSource, T2, TResult1> action, TSource firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<TSource, T2, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<TSource, T2, TResult1>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, Func<TSource, T2, TResult1> action, TSource firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<TSource, T2, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TComparer0, TResult1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<T0, TAction0, TResult1>
            (in RangeRepeatEnumerable<T0, TAction0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<T0, TResult1>
            (in RingBuffer<T0>
                second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0, TResult1>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0, TResult1>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TEnumerable1, TEnumerator1, TAction0, TResult1>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0, TResult1>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<T0, TResult1>
            (in UnrolledLinkedList<T0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<TSource, T0, TResult1> action, TSource firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<TSource, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                TResult1,
                DelegateFuncToAction<TSource, TResult0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0, TResult1>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            second, Func<TSource, TResult0, TResult1> action, TSource firstDefaultValue = default, TResult0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TResult0 : unmanaged
            where TResult1 : unmanaged
            where TAction0 : struct, IRefAction<T0, T1, TResult0>
            => new ZipEnumerable<
                SetOperationEnumerable<TFirstEnumerable, TFirstEnumerator, TSecondEnumerable, TSecondEnumerator, TSource, TSetOperation>,
                Enumerator,
                TSource,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                TResult1,
                DelegateFuncToAction<TSource, TResult0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);
        #endregion
    }
}
