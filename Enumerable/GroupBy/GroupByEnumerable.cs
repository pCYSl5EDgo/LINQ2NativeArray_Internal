using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace pcysl5edgo.Collections.LINQ
{
    public unsafe readonly struct
        GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>
        : IRefEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>.Enumerator, Grouping<TKey, TElement>>
        where TSource : unmanaged
        where TKey : unmanaged
        where TElement : unmanaged
        where TEnumerator : struct, IRefEnumerator<TSource>
        where TEnumerable : struct, IRefEnumerable<TEnumerator, TSource>
        where TKeySelector : struct, IRefFunc<TSource, TKey>
        where TElementSelector : struct, IRefFunc<TSource, TElement>
        where TEqualityComparer : struct, IRefFunc<TKey, TKey, bool>
    {
        private readonly TEnumerable enumerable;
        private readonly TKeySelector keySelector;
        private readonly TElementSelector elementSelector;
        private readonly TEqualityComparer equalityComparer;
        private readonly Allocator alloc;
        public readonly GroupByDisposeOptions GroupByDisposeOption;

        public GroupByEnumerable(in TEnumerable enumerable, in TKeySelector keySelector, in TElementSelector elementSelector, in TEqualityComparer equalityComparer, Allocator allocator, GroupByDisposeOptions groupByDisposeOption)
        {
            this.enumerable = enumerable;
            this.keySelector = keySelector;
            this.elementSelector = elementSelector;
            this.equalityComparer = equalityComparer;
            alloc = allocator;
            GroupByDisposeOption = groupByDisposeOption;
        }

        public struct Enumerator
            : IRefEnumerator<Grouping<TKey, TElement>>
        {
            internal Grouping<TKey, TElement>* Groups;
            internal long Count;
            private long index;
            private readonly Allocator allocator;
            private readonly GroupByDisposeOptions option;

            private const long INITIAL_CAPACITY = 16L;

            internal Enumerator(in TEnumerable enumerable, TKeySelector keySelector, TElementSelector elementSelector, TEqualityComparer equalityComparer, Allocator allocator, GroupByDisposeOptions option)
            {
                this.option = option;
                index = -1;
                Count = 0;
                this.allocator = allocator;
                if (enumerable.CanFastCount() && enumerable.LongCount() == 0)
                {
                    Groups = null;
                    return;
                }
                var capacity = INITIAL_CAPACITY;
                Groups = UnsafeUtilityEx.Malloc<Grouping<TKey, TElement>>(capacity, allocator);
                var capacities = UnsafeUtilityEx.Malloc<long>(capacity, Allocator.Temp);
                var enumerator = enumerable.GetEnumerator();
                EnumerateAndSort(ref capacity, ref enumerator, ref capacities, ref keySelector, ref elementSelector, ref equalityComparer);
                UnsafeUtility.Free(capacities, Allocator.Temp);
                enumerator.Dispose();
            }

            private void EnumerateAndSort(ref long capacity, ref TEnumerator enumerator, ref long* capacities, ref TKeySelector keySelector, ref TElementSelector elementSelector, ref TEqualityComparer equalityComparer)
            {
                TKey key;
                while (enumerator.MoveNext())
                {
                    ref var current = ref enumerator.Current;
                    key = keySelector.Calc(ref current);
                    long insertIndex = LinearSearchInsertIndex(ref key, ref equalityComparer);
                    if (capacity == insertIndex)
                        ReAllocGroups(ref capacity, ref capacities, in key);
                    ref var group = ref Groups[insertIndex];
                    ref var capa = ref capacities[insertIndex];
                    if (capa == 0)
                        AllocGroup(key, ref group, ref capa);
                    InsertTo(ref group, ref capa, ref current, ref elementSelector);
                }
            }

            private void InsertTo(ref Grouping<TKey, TElement> group, ref long capa, ref TSource current, ref TElementSelector elementSelector)
            {
                if (capa == group.Length)
                {
                    UnsafeUtilityEx.ReAlloc(ref group.Elements, capa, capa << 1, allocator);
                    capa <<= 1;
                }
                group.Elements[group.Length++] = elementSelector.Calc(ref current);
            }

            private void AllocGroup(in TKey key, ref Grouping<TKey, TElement> group, ref long capacity)
            {
                group.Key = key;
                group.Allocator = allocator;
                capacity = INITIAL_CAPACITY;
                group.Elements = UnsafeUtilityEx.Malloc<TElement>(capacity, allocator);
                group.Length = 0;
            }

            private long LinearSearchInsertIndex(ref TKey key, ref TEqualityComparer equalityComparer)
            {
                for (var i = 0L; i < Count; i++)
                    if (equalityComparer.Calc(ref key, ref Groups[i].Key))
                        return i;
                return Count++;
            }

            private void ReAllocGroups(ref long capacity, ref long* capacities, in TKey key)
            {
                UnsafeUtilityEx.ReAlloc(ref capacities, capacity, capacity << 1, Allocator.Temp);
                UnsafeUtilityEx.ReAlloc(ref Groups, capacity, capacity << 1, allocator);
                UnsafeUtility.MemClear(capacities + capacity, sizeof(long) * capacity);
                capacity <<= 1;
            }

            public ref Grouping<TKey, TElement> Current => ref Groups[index];
            Grouping<TKey, TElement> IEnumerator<Grouping<TKey, TElement>>.Current => Current;
            object IEnumerator.Current => Current;

            public void Dispose()
            {
                switch (option)
                {
                    case GroupByDisposeOptions.Recursive:
                        if (Groups != null)
                            for (var i = 0L; i < Count; i++)
                                Groups[i].Dispose();
                        goto case GroupByDisposeOptions.GroupCollectionOnly;
                    case GroupByDisposeOptions.GroupCollectionOnly:
                        if (Groups != null && UnsafeUtility.IsValidAllocator(allocator))
                            UnsafeUtility.Free(Groups, allocator);
                        break;
                    case GroupByDisposeOptions.None:
                    default:
                        break;
                }
                this = default;
            }

            public bool MoveNext() => ++index < Count;

            public void Reset() => index = -1;
        }

        public readonly Enumerator GetEnumerator() => new Enumerator(in enumerable, keySelector, elementSelector, equalityComparer, alloc, GroupByDisposeOption);
        public readonly Enumerator GetEnumerator(Allocator allocator, GroupByDisposeOptions option) => new Enumerator(in enumerable, keySelector, elementSelector, equalityComparer, allocator, option);

        #region Interface Implementation
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly IEnumerator<Grouping<TKey, TElement>> IEnumerable<Grouping<TKey, TElement>>.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool CanFastCount() => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Any()
        {
            var enumerator = GetEnumerator();
            if (enumerator.MoveNext())
            {
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Count()
            => (int)LongCount();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly long LongCount()
        {
            var enumerator = GetEnumerator();
            var count = 0L;
            while (enumerator.MoveNext())
                ++count;
            enumerator.Dispose();
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly void CopyTo(Grouping<TKey, TElement>* dest)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                *dest++ = enumerator.Current;
            enumerator.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Grouping<TKey, TElement>[] ToArray()
        {
            var count = LongCount();
            if (count == 0) return Array.Empty<Grouping<TKey, TElement>>();
            var answer = new Grouping<TKey, TElement>[count];
            CopyTo((Grouping<TKey, TElement>*)Unsafe.AsPointer(ref answer[0]));
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly NativeEnumerable<Grouping<TKey, TElement>> ToNativeEnumerable(Allocator allocator)
        {
            var count = LongCount();
            var ptr = UnsafeUtilityEx.Malloc<Grouping<TKey, TElement>>(count, allocator);
            CopyTo(ptr);
            return new NativeEnumerable<Grouping<TKey, TElement>>(ptr, count);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly NativeArray<Grouping<TKey, TElement>> ToNativeArray(Allocator allocator)
        {
            var count = Count();
            if (count == 0) return default;
            var answer = new NativeArray<Grouping<TKey, TElement>>(count, allocator, NativeArrayOptions.UninitializedMemory);
            CopyTo(UnsafeUtilityEx.GetPointer(answer));
            return answer;
        }
        #endregion

        #region Enumerable
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly AppendEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>>
            Append(Grouping<TKey, TElement> value, Allocator allocator = Allocator.Temp)
            => new AppendEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>>(this, value, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer> AsRefEnumerable() => this;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DefaultIfEmptyEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>>
            DefaultIfEmpty(Grouping<TKey, TElement> defaultValue, Allocator allocator = Allocator.Temp)
            => new DefaultIfEmptyEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>>(this, defaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator, Grouping<TKey, TElement>, DefaultEqualityComparer<Grouping<TKey, TElement>>, DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Distinct(Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DefaultEqualityComparer<Grouping<TKey, TElement>>, DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>(this, default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>
            Distinct<TEqualityComparer0, TGetHashCodeFunc0>(in TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>(this, comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TComparer0
            >
            OrderBy<TComparer0>(in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new OrderByEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TComparer0>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByFromFunc<Grouping<TKey, TElement>>
            >
            OrderBy(Func<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int> comparer, Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, OrderByFromFunc<Grouping<TKey, TElement>>>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByDescending<Grouping<TKey, TElement>, TComparer0>
            >
            OrderByDescending<TComparer0>(in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new OrderByEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, OrderByDescending<Grouping<TKey, TElement>, TComparer0>>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByDescending<Grouping<TKey, TElement>, OrderByFromFunc<Grouping<TKey, TElement>>>
            >
            OrderByDescending(Func<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int> comparer, Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, OrderByDescending<Grouping<TKey, TElement>, OrderByFromFunc<Grouping<TKey, TElement>>>>(this, (OrderByFromFunc<Grouping<TKey, TElement>>)comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
        (
            NativeEnumerable<Grouping<TKey, TElement>> True,
            NativeEnumerable<Grouping<TKey, TElement>> False
        )
        ToPartition(Func<Grouping<TKey, TElement>, bool> predicate, Allocator allocator = Allocator.Temp)
        {

            var True = new NativeList<Grouping<TKey, TElement>>(allocator);
            var False = new NativeList<Grouping<TKey, TElement>>(allocator);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate(enumerator.Current))
                    True.Add(enumerator.Current);
                else
                    False.Add(enumerator.Current);
            }
            enumerator.Dispose();
            return (True.AsNativeEnumerable(), False.AsNativeEnumerable());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
        (
            NativeEnumerable<Grouping<TKey, TElement>> True,
            NativeEnumerable<Grouping<TKey, TElement>> False
        )
        ToPartition<TPredicate0>(in TPredicate0 predicate, Allocator allocator = Allocator.Temp)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
        {

            var True = new NativeList<Grouping<TKey, TElement>>(allocator);
            var False = new NativeList<Grouping<TKey, TElement>>(allocator);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate.Calc(ref enumerator.Current))
                    True.Add(enumerator.Current);
                else
                    False.Add(enumerator.Current);
            }
            enumerator.Dispose();
            return (True.AsNativeEnumerable(), False.AsNativeEnumerable());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            PrependEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >
            Prepend(Grouping<TKey, TElement> value, Allocator allocator = Allocator.Temp)
            => new PrependEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>>(this, value, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ReverseEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>>
            Reverse(Allocator allocator = Allocator.Temp)
            => new ReverseEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>>(this, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectIndexEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TNextResult0, TNextAction0>
            SelectIndex<TNextResult0, TNextAction0>(TNextAction0 action, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            where TNextAction0 : struct, ISelectIndex<Grouping<TKey, TElement>, TNextResult0>
            => new SelectIndexEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TNextResult0, TNextAction0>(this, action, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectIndexEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TNextResult0, DelegateFuncToSelectIndexStructOperator<Grouping<TKey, TElement>, TNextResult0>>
            SelectIndex<TNextResult0>(Func<Grouping<TKey, TElement>, long, TNextResult0> func, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            => new SelectIndexEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TNextResult0, DelegateFuncToSelectIndexStructOperator<Grouping<TKey, TElement>, TNextResult0>>(this, func, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TNextResult0, TNextAction0>
            Select<TNextResult0, TNextAction0>(TNextAction0 action, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            where TNextAction0 : struct, IRefAction<Grouping<TKey, TElement>, TNextResult0>
            => new SelectEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TNextResult0, TNextAction0>(this, action, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TNextResult0, DelegateFuncToAction<Grouping<TKey, TElement>, TNextResult0>>
            Select<TNextResult0>(Func<Grouping<TKey, TElement>, TNextResult0> func, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            => new SelectEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TNextResult0, DelegateFuncToAction<Grouping<TKey, TElement>, TNextResult0>>(this, func, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                TResultAction
            >
            SelectMany<TResult0, TResultEnumerable0, TResultEnumerator0, TResultAction>(TResultAction action)
            where TResult0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<TResult0>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TResult0>
            where TResultAction : struct, IRefAction<Grouping<TKey, TElement>, TResultEnumerable0>
            => new SelectManyEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TResult0, TResultEnumerable0, TResultEnumerator0, TResultAction>(this, action);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                DelegateFuncToAction<Grouping<TKey, TElement>, TResultEnumerable0>
            >
            SelectMany<TResult0, TResultEnumerable0, TResultEnumerator0>(Func<Grouping<TKey, TElement>, TResultEnumerable0> func)
            where TResult0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<TResult0>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TResult0>
            => new SelectManyEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                DelegateFuncToAction<Grouping<TKey, TElement>, TResultEnumerable0>
            >(this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >
            Skip(long count)
            => new SkipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >(this, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipLastEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >
            SkipLast(long count, Allocator allocator = Allocator.Temp)
            => new SkipLastEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >(this, count, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipWhileEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TPredicate0
            >
            SkipWhileIndex<TPredicate0>(in TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new SkipWhileEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >
            Take(long count)
            => new TakeEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >(this, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeWhileEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TPredicate0
            >
            TakeWhileIndex<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new TakeWhileEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeLastEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >
            TakeLast(long count, Allocator allocator = Allocator.Temp)
            => new TakeLastEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>
            >(this, count, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectIndexEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                (Grouping<TKey, TElement>, long),
                WithIndex<Grouping<TKey, TElement>>
            >
            WithIndex(Allocator allocator = Allocator.Temp)
            => new SelectIndexEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                (Grouping<TKey, TElement>, long),
                WithIndex<Grouping<TKey, TElement>>
            >(this, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TPredicate0
            >
            Where<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new WhereEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, bool>
            >
            Where(Func<Grouping<TKey, TElement>, bool> predicate)
            => new WhereEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, bool>
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereIndexEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TPredicate0
            >
            WhereIndex<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => new WhereIndexEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereIndexEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DelegateFuncToWhereIndexStructOperator<Grouping<TKey, TElement>>
            >
            WhereIndex(Func<Grouping<TKey, TElement>, long, bool> predicate)
            => new WhereIndexEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DelegateFuncToWhereIndexStructOperator<Grouping<TKey, TElement>>
            >(this, predicate);
        #endregion
        #region Concat
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TEnumerable1,
                TEnumerator1,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable1, TEnumerator1>
            (in TEnumerable1 second)
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TEnumerable1, TEnumerator1,
                Grouping<TKey, TElement>
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2>
            (in ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, Grouping<TKey, TElement>> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable2 : struct, IRefEnumerable<TEnumerator2, Grouping<TKey, TElement>>
            where TEnumerator2 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat(NativeArray<Grouping<TKey, TElement>> second)
            => new ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>
                >(this, NativeEnumerable.AsRefEnumerable(second));


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat(in NativeEnumerable<Grouping<TKey, TElement>> second)
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                AppendEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable1, TEnumerator1>
            (in AppendEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                AppendEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat(in ArrayEnumerable<Grouping<TKey, TElement>> second)
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat(in Grouping<TKey, TElement>[] second)
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, NativeEnumerable.AsRefEnumerable(second));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable1, TEnumerator1>
            (in DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DistinctEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable1, TEnumerator1, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DistinctEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TKey0>
            (in Grouping<TKey0, Grouping<TKey, TElement>> second)
            where TKey0 : unmanaged
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, Grouping<TKey, TElement>, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, Grouping<TKey, TElement>, T0Selector, TKeyEqualityComparer0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0Selector, TKeyEqualityComparer0>
            (in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, Grouping<TKey, TElement>, T0Selector, TKeyEqualityComparer0>
            second)
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                Grouping<TKey, TElement>>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, Grouping<TKey, TElement>, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, Grouping<TKey, TElement>, T0Selector, TKeyEqualityComparer0>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer0>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer0>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer0> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer0>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer0>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction1>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction1>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TAction1>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction1> second)
            where TAction1 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction1>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction1>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat
            (in RingBuffer<Grouping<TKey, TElement>> second)
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1>,
                SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable1, TEnumerator1, TPrevSource1, TAction1>
            (in SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1> second)
            where TEnumerator1 : struct, IRefEnumerator<TPrevSource1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TPrevSource1>
            where TAction1 : struct, IRefAction<TPrevSource1, Grouping<TKey, TElement>>
            where TPrevSource1 : unmanaged
            => new ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1>,
                    SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1>.Enumerator,
                    Grouping<TKey, TElement>>
                (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1>,
                SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable1, TEnumerator1, TPrevSource1, TAction1>
            (in SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1> second)
            where TEnumerator1 : struct, IRefEnumerator<TPrevSource1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TPrevSource1>
            where TAction1 : struct, ISelectIndex<TPrevSource1, Grouping<TKey, TElement>>
            where TPrevSource1 : unmanaged
            => new ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1>,
                    SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, Grouping<TKey, TElement>, TAction1>.Enumerator,
                    Grouping<TKey, TElement>>
                (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TResultEnumerable0, TResultEnumerator0, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TResultEnumerable0, TResultEnumerator0, TAction0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0, TPrevSource0, TResultEnumerable0, TResultEnumerator0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TResultEnumerable0, TResultEnumerator0, TAction0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevSource0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, Grouping<TKey, TElement>>
            where TAction0 : struct, IRefAction<TPrevSource0, TResultEnumerable0>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TResultEnumerable0, TResultEnumerator0, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TResultEnumerable0, TResultEnumerator0, TAction0>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TEnumerator0,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0>(in SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TEnumerator0,
                Grouping<TKey, TElement>
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0>(in TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TEnumerator0,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TEnumerator0,
                Grouping<TKey, TElement>
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0>(in SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0>(in TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                UnrolledLinkedList<Grouping<TKey, TElement>>,
                UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat(in UnrolledLinkedList<Grouping<TKey, TElement>> second)
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                UnrolledLinkedList<Grouping<TKey, TElement>>,
                UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TPrevEnumerable0, TPrevEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, Grouping<TKey, TElement>, TPredicate0> second)
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, Grouping<TKey, TElement>>
            where TPrevEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => new ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>>(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>
            >
            Concat<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0> second)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => new ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>>(this, second);
        #endregion

        #region Except
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer0>
            (in TEnumerable0 second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in NativeEnumerable<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, NativeEnumerable<Grouping<TKey, TElement>>, NativeEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, NativeEnumerable<Grouping<TKey, TElement>>, NativeEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0>
            (NativeArray<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, NativeEnumerable<Grouping<TKey, TElement>>, NativeEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, NativeEnumerable<Grouping<TKey, TElement>>, NativeEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in ArrayEnumerable<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ArrayEnumerable<Grouping<TKey, TElement>>, ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ArrayEnumerable<Grouping<TKey, TElement>>, ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0>
            (Grouping<TKey, TElement>[] second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ArrayEnumerable<Grouping<TKey, TElement>>, ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ArrayEnumerable<Grouping<TKey, TElement>>, ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TKey0, TComparer0>
            (in Grouping<TKey0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >(this, second, new ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >(comparer), allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer1 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TAction0>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TAction0 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>, RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>, RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in RingBuffer<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TEnumerator0,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TEnumerator0,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TEnumerator0,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TEnumerator0,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                UnrolledLinkedList<Grouping<TKey, TElement>>,
                UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in UnrolledLinkedList<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                UnrolledLinkedList<Grouping<TKey, TElement>>,
                UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, ExceptOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);
        #endregion

        #region GroupJoin
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    TEnumerable0,
                    TEnumerator0,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    ArrayEnumerable<T0>,
                    ArrayEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    ArrayEnumerable<T0>,
                    ArrayEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                TKey1,
                T1,
                T0Selector,
                TEqualityComparer0
            >(in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            GroupJoin<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<Grouping<TKey, TElement>, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct,
            IRefFunc<Grouping<TKey, TElement>,
                WhereIndexEnumerable<
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    GroupJoinPredicate<T0, TKey1, TKeyEqualityComparer1>
                    >,
                T1>
            =>
            new GroupJoinEnumerable
            <
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable
            <
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            GroupJoin<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<Grouping<TKey, TElement>, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct,
            IRefFunc<Grouping<TKey, TElement>,
                WhereIndexEnumerable<
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    GroupJoinPredicate<T0, TKey1, TKeyEqualityComparer1>
                    >,
                T1>
            =>
            new GroupJoinEnumerable
            <
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    RangeRepeatEnumerable<T0, TAction0>,
                    RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TAction0 : struct, IRangeRepeat<T0>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, RangeRepeatEnumerable<T0, TAction0>, RangeRepeatEnumerable<T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey, TElement>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new GroupJoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);
        #endregion

        #region Intersect
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer0>
            (in TEnumerable0 second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in NativeEnumerable<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, NativeEnumerable<Grouping<TKey, TElement>>, NativeEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, NativeEnumerable<Grouping<TKey, TElement>>, NativeEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (NativeArray<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, NativeEnumerable<Grouping<TKey, TElement>>, NativeEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, NativeEnumerable<Grouping<TKey, TElement>>, NativeEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in ArrayEnumerable<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ArrayEnumerable<Grouping<TKey, TElement>>, ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ArrayEnumerable<Grouping<TKey, TElement>>, ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (Grouping<TKey, TElement>[] second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ArrayEnumerable<Grouping<TKey, TElement>>, ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ArrayEnumerable<Grouping<TKey, TElement>>, ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TKey0, TComparer0>
            (in Grouping<TKey0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer1 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TAction0>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TAction0 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>, RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>, RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in RingBuffer<Grouping<TKey, TElement>> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, IntersectOperation<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator, Grouping<TKey, TElement>, TComparer0>>
                (this, second, comparer, allocator);
        #endregion

        #region Join
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TKey1 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<Grouping<TKey, TElement>, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            =>
            new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<Grouping<TKey, TElement>, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            =>
            new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, RangeRepeatEnumerable<T0, TAction0>, RangeRepeatEnumerable<T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);
        #endregion

        #region Max
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetMax(out Grouping<TKey, TElement> value)
        {
            value = default;
            if (typeof(Grouping<TKey, TElement>) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, byte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, short>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, ushort>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, int>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, uint>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, long>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, ulong>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, float>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, double>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, decimal>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Grouping<TKey, TElement> Max()
        {
            Grouping<TKey, TElement> value;
            if (typeof(Grouping<TKey, TElement>) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, byte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, short>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, ushort>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, int>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, uint>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, long>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, ulong>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, float>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, double>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, decimal>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
            INITIALIZE:
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref value);
                if (!max.HasValue) goto INITIALIZE;
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref enumerator.Current);
                    if (!current.HasValue || current.Value <= max.Value) continue;
                    max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(byte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMax<TResult0>(Func<Grouping<TKey, TElement>, TResult0> func, out TResult0 value)
            where TResult0 : unmanaged
        {
            value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TResult0 Max<TResult0>(Func<Grouping<TKey, TElement>, TResult0> func)
            where TResult0 : unmanaged
        {
            TResult0 value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
        #endregion

        #region MaxByFirst
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, byte> func, out (Grouping<TKey, TElement> value, byte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, byte?> func, out (Grouping<TKey, TElement> value, byte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, byte> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, byte?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            byte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, sbyte> func, out (Grouping<TKey, TElement> value, sbyte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, sbyte?> func, out (Grouping<TKey, TElement> value, sbyte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, sbyte> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, sbyte?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            sbyte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, short> func, out (Grouping<TKey, TElement> value, short key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, short?> func, out (Grouping<TKey, TElement> value, short? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, short> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, short?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            short? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, short?> func)
        {
            var enumerator = GetEnumerator();
            short? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, ushort> func, out (Grouping<TKey, TElement> value, ushort key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, ushort?> func, out (Grouping<TKey, TElement> value, ushort? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, ushort> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, ushort?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ushort? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, int> func, out (Grouping<TKey, TElement> value, int key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, int?> func, out (Grouping<TKey, TElement> value, int? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, int> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, int?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            int? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, int?> func)
        {
            var enumerator = GetEnumerator();
            int? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, uint> func, out (Grouping<TKey, TElement> value, uint key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, uint?> func, out (Grouping<TKey, TElement> value, uint? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, uint> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, uint?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            uint? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, long> func, out (Grouping<TKey, TElement> value, long key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, long?> func, out (Grouping<TKey, TElement> value, long? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, long> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, long?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            long? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, long?> func)
        {
            var enumerator = GetEnumerator();
            long? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, ulong> func, out (Grouping<TKey, TElement> value, ulong key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, ulong?> func, out (Grouping<TKey, TElement> value, ulong? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, ulong> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, ulong?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ulong? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, float> func, out (Grouping<TKey, TElement> value, float key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, float?> func, out (Grouping<TKey, TElement> value, float? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, float> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, float?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            float? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, float?> func)
        {
            var enumerator = GetEnumerator();
            float? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, double> func, out (Grouping<TKey, TElement> value, double key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, double?> func, out (Grouping<TKey, TElement> value, double? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, double> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, double?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            double? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, double?> func)
        {
            var enumerator = GetEnumerator();
            double? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, decimal> func, out (Grouping<TKey, TElement> value, decimal key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, decimal?> func, out (Grouping<TKey, TElement> value, decimal? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, decimal> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<Grouping<TKey, TElement>, decimal?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            decimal? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByFirst(Func<Grouping<TKey, TElement>, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        #endregion

        #region MaxByLast
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, byte> func, out (Grouping<TKey, TElement> value, byte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, byte?> func, out (Grouping<TKey, TElement> value, byte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, byte> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, byte?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            byte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, sbyte> func, out (Grouping<TKey, TElement> value, sbyte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, sbyte?> func, out (Grouping<TKey, TElement> value, sbyte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, sbyte> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, sbyte?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            sbyte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, short> func, out (Grouping<TKey, TElement> value, short key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, short?> func, out (Grouping<TKey, TElement> value, short? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, short> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, short?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            short? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, short?> func)
        {
            var enumerator = GetEnumerator();
            short? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, ushort> func, out (Grouping<TKey, TElement> value, ushort key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, ushort?> func, out (Grouping<TKey, TElement> value, ushort? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, ushort> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, ushort?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ushort? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, int> func, out (Grouping<TKey, TElement> value, int key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, int?> func, out (Grouping<TKey, TElement> value, int? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, int> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, int?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            int? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, int?> func)
        {
            var enumerator = GetEnumerator();
            int? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, uint> func, out (Grouping<TKey, TElement> value, uint key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, uint?> func, out (Grouping<TKey, TElement> value, uint? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, uint> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, uint?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            uint? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, long> func, out (Grouping<TKey, TElement> value, long key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, long?> func, out (Grouping<TKey, TElement> value, long? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, long> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, long?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            long? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, long?> func)
        {
            var enumerator = GetEnumerator();
            long? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, ulong> func, out (Grouping<TKey, TElement> value, ulong key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, ulong?> func, out (Grouping<TKey, TElement> value, ulong? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, ulong> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, ulong?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ulong? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, float> func, out (Grouping<TKey, TElement> value, float key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, float?> func, out (Grouping<TKey, TElement> value, float? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, float> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, float?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            float? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, float?> func)
        {
            var enumerator = GetEnumerator();
            float? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, double> func, out (Grouping<TKey, TElement> value, double key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, double?> func, out (Grouping<TKey, TElement> value, double? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, double> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, double?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            double? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, double?> func)
        {
            var enumerator = GetEnumerator();
            double? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, decimal> func, out (Grouping<TKey, TElement> value, decimal key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, decimal?> func, out (Grouping<TKey, TElement> value, decimal? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, decimal> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<Grouping<TKey, TElement>, decimal?> func, out Grouping<TKey, TElement> max)
        {
            var enumerator = GetEnumerator();
            max = default;
            decimal? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MaxByLast(Func<Grouping<TKey, TElement>, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? maxKey;
            Grouping<TKey, TElement> maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        #endregion

        #region Min
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetMin(out Grouping<TKey, TElement> value)
        {
            value = default;
            if (typeof(Grouping<TKey, TElement>) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, byte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, short>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, ushort>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, int>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, uint>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, long>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, ulong>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, float>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, double>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, decimal>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Grouping<TKey, TElement> Min()
        {
            Grouping<TKey, TElement> value;
            if (typeof(Grouping<TKey, TElement>) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, byte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, short>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, ushort>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, int>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, uint>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, long>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, ulong>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, float>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, double>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<Grouping<TKey, TElement>, decimal>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
            INITIALIZE:
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref value);
                if (!min.HasValue) goto INITIALIZE;
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref enumerator.Current);
                    if (!current.HasValue || current.Value <= min.Value) continue;
                    min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(byte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<Grouping<TKey, TElement>, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMin<TResult0>(Func<Grouping<TKey, TElement>, TResult0> func, out TResult0 value)
            where TResult0 : unmanaged
        {
            value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TResult0 Min<TResult0>(Func<Grouping<TKey, TElement>, TResult0> func)
            where TResult0 : unmanaged
        {
            TResult0 value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
        #endregion

        #region MinByFirst
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, byte> func, out (Grouping<TKey, TElement> value, byte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, byte?> func, out (Grouping<TKey, TElement> value, byte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, byte> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, byte?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            byte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, sbyte> func, out (Grouping<TKey, TElement> value, sbyte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, sbyte?> func, out (Grouping<TKey, TElement> value, sbyte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, sbyte> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, sbyte?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            sbyte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, short> func, out (Grouping<TKey, TElement> value, short key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, short?> func, out (Grouping<TKey, TElement> value, short? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, short> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, short?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            short? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, short?> func)
        {
            var enumerator = GetEnumerator();
            short? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, ushort> func, out (Grouping<TKey, TElement> value, ushort key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, ushort?> func, out (Grouping<TKey, TElement> value, ushort? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, ushort> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, ushort?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ushort? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, int> func, out (Grouping<TKey, TElement> value, int key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, int?> func, out (Grouping<TKey, TElement> value, int? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, int> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, int?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            int? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, int?> func)
        {
            var enumerator = GetEnumerator();
            int? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, uint> func, out (Grouping<TKey, TElement> value, uint key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, uint?> func, out (Grouping<TKey, TElement> value, uint? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, uint> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, uint?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            uint? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, long> func, out (Grouping<TKey, TElement> value, long key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, long?> func, out (Grouping<TKey, TElement> value, long? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, long> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, long?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            long? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, long?> func)
        {
            var enumerator = GetEnumerator();
            long? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, ulong> func, out (Grouping<TKey, TElement> value, ulong key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, ulong?> func, out (Grouping<TKey, TElement> value, ulong? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, ulong> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, ulong?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ulong? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, float> func, out (Grouping<TKey, TElement> value, float key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, float?> func, out (Grouping<TKey, TElement> value, float? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, float> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, float?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            float? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, float?> func)
        {
            var enumerator = GetEnumerator();
            float? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, double> func, out (Grouping<TKey, TElement> value, double key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, double?> func, out (Grouping<TKey, TElement> value, double? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, double> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, double?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            double? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, double?> func)
        {
            var enumerator = GetEnumerator();
            double? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, decimal> func, out (Grouping<TKey, TElement> value, decimal key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, decimal?> func, out (Grouping<TKey, TElement> value, decimal? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, decimal> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<Grouping<TKey, TElement>, decimal?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            decimal? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByFirst(Func<Grouping<TKey, TElement>, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        #endregion

        #region MinByLast
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, byte> func, out (Grouping<TKey, TElement> value, byte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, byte?> func, out (Grouping<TKey, TElement> value, byte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, byte> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, byte?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            byte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, sbyte> func, out (Grouping<TKey, TElement> value, sbyte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, sbyte?> func, out (Grouping<TKey, TElement> value, sbyte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, sbyte> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, sbyte?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            sbyte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, short> func, out (Grouping<TKey, TElement> value, short key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, short?> func, out (Grouping<TKey, TElement> value, short? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, short> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, short?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            short? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, short?> func)
        {
            var enumerator = GetEnumerator();
            short? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, ushort> func, out (Grouping<TKey, TElement> value, ushort key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, ushort?> func, out (Grouping<TKey, TElement> value, ushort? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, ushort> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, ushort?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ushort? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, int> func, out (Grouping<TKey, TElement> value, int key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, int?> func, out (Grouping<TKey, TElement> value, int? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, int> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, int?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            int? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, int?> func)
        {
            var enumerator = GetEnumerator();
            int? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, uint> func, out (Grouping<TKey, TElement> value, uint key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, uint?> func, out (Grouping<TKey, TElement> value, uint? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, uint> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, uint?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            uint? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, long> func, out (Grouping<TKey, TElement> value, long key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, long?> func, out (Grouping<TKey, TElement> value, long? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, long> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, long?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            long? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, long?> func)
        {
            var enumerator = GetEnumerator();
            long? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, ulong> func, out (Grouping<TKey, TElement> value, ulong key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, ulong?> func, out (Grouping<TKey, TElement> value, ulong? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, ulong> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, ulong?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ulong? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, float> func, out (Grouping<TKey, TElement> value, float key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, float?> func, out (Grouping<TKey, TElement> value, float? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, float> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, float?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            float? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, float?> func)
        {
            var enumerator = GetEnumerator();
            float? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, double> func, out (Grouping<TKey, TElement> value, double key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, double?> func, out (Grouping<TKey, TElement> value, double? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, double> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, double?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            double? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, double?> func)
        {
            var enumerator = GetEnumerator();
            double? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, decimal> func, out (Grouping<TKey, TElement> value, decimal key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, decimal?> func, out (Grouping<TKey, TElement> value, decimal? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, decimal> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<Grouping<TKey, TElement>, decimal?> func, out Grouping<TKey, TElement> min)
        {
            var enumerator = GetEnumerator();
            min = default;
            decimal? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Grouping<TKey, TElement> MinByLast(Func<Grouping<TKey, TElement>, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? minKey;
            Grouping<TKey, TElement> minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        #endregion

        public
            MinMaxByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                MinByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            MinBy<TKey0>(Func<Grouping<TKey, TElement>, TKey0> func)
            where TKey0 : unmanaged
            => new MinMaxByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                MinByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            (this, func, default, default);

        public
            MinMaxByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                MaxByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            MaxBy<TKey0>(Func<Grouping<TKey, TElement>, TKey0> func)
            where TKey0 : unmanaged
            => new MinMaxByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                MaxByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            (this, func, default, default);

        #region Union
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TEnumerable0 second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>, ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>
                (Concat<TEnumerable0, TEnumerator0>(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                    second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in NativeEnumerable<Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (NativeArray<Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in ArrayEnumerable<Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (Grouping<TKey, TElement>[]
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, TGetHashCodeFunc0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TEqualityComparer1, TGetHashCodeFunc1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TEqualityComparer1 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc1 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TKey0>
            (in Grouping<TKey0, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(in second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>,
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                Grouping<TKey, TElement>>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>,
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>,
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>,
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TAction0, TEqualityComparer0, TGetHashCodeFunc0>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in RingBuffer<Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TPrevEnumerable0, TPrevEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPrevSource0, TAction0>
            (in SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TPrevEnumerable0, TPrevEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, ISelectIndex<TPrevSource0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, T0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>
            => new DistinctEnumerable<ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator, Grouping<TKey, TElement>>, ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator, Grouping<TKey, TElement>>.Enumerator, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in UnrolledLinkedList<Grouping<TKey, TElement>>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);
        #endregion

        #region SequenceEqual
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TEnumerable0 second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
        {
            var enumerator0 = GetEnumerator();
            var enumerator1 = second.GetEnumerator();
            while (true)
            {
                var b = enumerator0.MoveNext();
                if (b ^ enumerator1.MoveNext())
                {
                    enumerator0.Dispose();
                    enumerator1.Dispose();
                    return false;
                }
                if (!b)
                {
                    enumerator0.Dispose();
                    enumerator1.Dispose();
                    return true;
                }
                if (!comparer.Calc(ref enumerator0.Current, ref enumerator1.Current)) return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => SequenceEqual<
                TEnumerable0, TEnumerator0,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => SequenceEqual<
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in NativeEnumerable<Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in NativeEnumerable<Grouping<TKey, TElement>> second)
            => SequenceEqual<
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in NativeArray<Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(NativeEnumerable.AsRefEnumerable(second), comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in NativeArray<Grouping<TKey, TElement>> second)
            => SequenceEqual<
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(NativeEnumerable.AsRefEnumerable(second), default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in ArrayEnumerable<Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in ArrayEnumerable<Grouping<TKey, TElement>> second)
            => SequenceEqual<
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (Grouping<TKey, TElement>[] second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(NativeEnumerable.AsRefEnumerable(second), comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(Grouping<TKey, TElement>[] second)
            => SequenceEqual<
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(NativeEnumerable.AsRefEnumerable(second), default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            => SequenceEqual<
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => SequenceEqual<
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TEqualityComparer1, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TEqualityComparer1 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => SequenceEqual<
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0, TKey0>
            (in Grouping<TKey0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TKey0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >
            (second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer1, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc0> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => SequenceEqual<
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            => SequenceEqual<
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                Grouping<TKey, TElement>>
            => SequenceEqual<
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            => SequenceEqual<
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => SequenceEqual<
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => SequenceEqual<
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => SequenceEqual<
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0, TAction0>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0> second, in TEqualityComparer0 comparer)
            where TAction0 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TAction0>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0> second)
            where TAction0 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            => SequenceEqual<

                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,

                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => SequenceEqual<
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in RingBuffer<Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual
            (in RingBuffer<Grouping<TKey, TElement>> second)
            => SequenceEqual<
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, Grouping<TKey, TElement>>
            => SequenceEqual<
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, Grouping<TKey, TElement>>
            => SequenceEqual<
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<T0, Grouping<TKey, TElement>>
            => SequenceEqual<
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<T0, Grouping<TKey, TElement>>
            => SequenceEqual<
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, T0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => SequenceEqual<
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => SequenceEqual<
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>
            => SequenceEqual<
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>
            => SequenceEqual<
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TEnumerator0,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TEnumerator0,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in UnrolledLinkedList<Grouping<TKey, TElement>> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                UnrolledLinkedList<Grouping<TKey, TElement>>,
                UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => SequenceEqual<
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => SequenceEqual<
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => SequenceEqual<
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, T0, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => SequenceEqual<
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => SequenceEqual<
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                DefaultEqualityComparer<Grouping<TKey, TElement>>
            >(second, default);
        #endregion

        #region Zip
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TEnumerable0 second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >(this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TResult0, TAction0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TKey0, T0, TResult0, TAction0>
            (in Grouping<TKey0, T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult0, TAction0>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T2, TResult0>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult0, TAction0>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T2, TResult0>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction1>,
                RangeRepeatEnumerable<T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0, TAction1>
            (in RangeRepeatEnumerable<T0, TAction1>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRangeRepeat<T0>
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, RangeRepeatEnumerable<T0, TAction1>, RangeRepeatEnumerable<T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0>
            (in RingBuffer<T0>
                second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TAction1>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TAction1>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TEnumerable1, TEnumerator1, TAction1>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0, TResult0, TAction0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0>
            (in UnrolledLinkedList<T0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>.Enumerator,
                TResult1,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TResult1, TAction0, TAction1>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>
            second, TAction0 action, Grouping<TKey, TElement> firstDefaultValue = default, TResult1 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TAction1 : struct, IRefAction<T0, T1, TResult1>
            where TResult0 : unmanaged
            where TResult1 : unmanaged
            where TAction0 : struct, IRefAction<Grouping<TKey, TElement>, TResult1, TResult0>
            => new ZipEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>.Enumerator, TResult1, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);
        #endregion

        #region Zip ValueTuple
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TEnumerable0 second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TKey0, T0>
            (in Grouping<TKey0, T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (Grouping<TKey, TElement>, T2),
                ZipValueTuple<Grouping<TKey, TElement>, T2>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (Grouping<TKey, TElement>, T2),
                ZipValueTuple<Grouping<TKey, TElement>, T2>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (Grouping<TKey, TElement>, T2),
                ZipValueTuple<Grouping<TKey, TElement>, T2>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (Grouping<TKey, TElement>, T2),
                ZipValueTuple<Grouping<TKey, TElement>, T2>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >(this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<T0, TAction0>
            (in RangeRepeatEnumerable<T0, TAction0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<T0>
            (in RingBuffer<T0>
                second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<T0>
            (in UnrolledLinkedList<T0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (Grouping<TKey, TElement>, T0),
                ZipValueTuple<Grouping<TKey, TElement>, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                (Grouping<TKey, TElement>, TResult0),
                ZipValueTuple<Grouping<TKey, TElement>, TResult0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            second, Grouping<TKey, TElement> firstDefaultValue = default, TResult0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<T0, T1, TResult0>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                (Grouping<TKey, TElement>, TResult0),
                ZipValueTuple<Grouping<TKey, TElement>, TResult0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);
        #endregion

        #region Function
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool IsEmpty() => !Any();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Any<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!predicate.Calc(ref enumerator.Current)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Any(Func<Grouping<TKey, TElement>, bool> predicate)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!predicate(enumerator.Current)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool All<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate.Calc(ref enumerator.Current)) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool All(Func<Grouping<TKey, TElement>, bool> predicate)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate(enumerator.Current)) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly void Aggregate<TAccumulate0, TFunc0>(ref TAccumulate0 seed, TFunc0 func)
            where TFunc0 : struct, IRefAction<TAccumulate0, Grouping<TKey, TElement>>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                func.Execute(ref seed, ref enumerator.Current);
            enumerator.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TNextResult0 Aggregate<TAccumulate0, TNextResult0, TFunc0, TResultFunc0>(ref TAccumulate0 seed, TFunc0 func, TResultFunc0 resultFunc)
            where TFunc0 : struct, IRefAction<TAccumulate0, Grouping<TKey, TElement>>
            where TResultFunc0 : struct, IRefFunc<TAccumulate0, TNextResult0>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                func.Execute(ref seed, ref enumerator.Current);
            enumerator.Dispose();
            return resultFunc.Calc(ref seed);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Grouping<TKey, TElement> Aggregate(Func<Grouping<TKey, TElement>, Grouping<TKey, TElement>, Grouping<TKey, TElement>> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var seed = enumerator.Current;
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return seed;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TAccumulate0 Aggregate<TAccumulate0>(TAccumulate0 seed, Func<TAccumulate0, Grouping<TKey, TElement>, TAccumulate0> func)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return seed;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TNextResult0 Aggregate<TAccumulate0, TNextResult0>(TAccumulate0 seed, Func<TAccumulate0, Grouping<TKey, TElement>, TAccumulate0> func, Func<TAccumulate0, TNextResult0> resultFunc)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return resultFunc(seed);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(in Grouping<TKey, TElement> value) => Contains(in value, EqualityComparer<Grouping<TKey, TElement>>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(Grouping<TKey, TElement> value) => Contains(in value, EqualityComparer<Grouping<TKey, TElement>>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(in Grouping<TKey, TElement> value, IEqualityComparer<Grouping<TKey, TElement>> comparer)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!comparer.Equals(enumerator.Current, value)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(Grouping<TKey, TElement> value, IEqualityComparer<Grouping<TKey, TElement>> comparer) => Contains(in value, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains<TComparer0>(ref Grouping<TKey, TElement> value, ref TComparer0 comparer)
        where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!comparer.Calc(ref enumerator.Current, ref value)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains<TComparer0>(Grouping<TKey, TElement> value, TComparer0 comparer)
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            => Contains(ref value, ref comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Count(Func<Grouping<TKey, TElement>, bool> predicate)
            => (int)LongCount(predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Count<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => (int)LongCount(predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly long LongCount(Func<Grouping<TKey, TElement>, bool> predicate)
        {
            var enumerator = GetEnumerator();
            var count = 0L;
            while (enumerator.MoveNext())
                if (predicate(enumerator.Current))
                    ++count;
            enumerator.Dispose();
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly long LongCount<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
        {
            var enumerator = GetEnumerator();
            var count = 0L;
            while (enumerator.MoveNext())
                if (predicate.Calc(ref enumerator.Current))
                    ++count;
            enumerator.Dispose();
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetElementAt(long index, out Grouping<TKey, TElement> value)
        {
            if (index < 0)
            {
                value = default;
                return false;
            }
            var enumerator = GetEnumerator();
            for (var i = 0L; i < index; i++)
            {
                if (enumerator.MoveNext()) continue;
                value = default;
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetFirst(out Grouping<TKey, TElement> first)
        {
            var enumerator = GetEnumerator();
            if (enumerator.MoveNext())
            {
                first = enumerator.Current;
                enumerator.Dispose();
                return true;
            }
            first = default;
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetLast(out Grouping<TKey, TElement> last)
        {
            var enumerator = GetEnumerator();
            last = default;
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            while (enumerator.MoveNext())
                last = enumerator.Current;
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle(out Grouping<TKey, TElement> value)
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle<TPredicate0>(out Grouping<TKey, TElement> value, TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                if (!predicate.Calc(ref enumerator.Current)) continue;
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle(out Grouping<TKey, TElement> value, Func<Grouping<TKey, TElement>, bool> predicate)
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                if (!predicate(enumerator.Current)) continue;
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Dictionary<TKey0, TElement0> ToDictionary<TKey0, TElement0>(Func<Grouping<TKey, TElement>, TKey0> keySelector, Func<Grouping<TKey, TElement>, TElement0> elementSelector)
        {
            var answer = new Dictionary<TKey0, TElement0>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                ref var current = ref enumerator.Current;
                answer.Add(keySelector(current), elementSelector(current));
            }
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Dictionary<TKey0, TElement0> ToDictionary<TKey0, TElement0, TKey0Func, TElement0Func>(TKey0Func keySelector, TElement0Func elementSelector)
            where TKey0Func : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TElement0Func : struct, IRefFunc<Grouping<TKey, TElement>, TElement0>
        {
            var answer = new Dictionary<TKey0, TElement0>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                ref var current = ref enumerator.Current;
                answer.Add(keySelector.Calc(ref current), elementSelector.Calc(ref current));
            }
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly HashSet<Grouping<TKey, TElement>> ToHashSet()
        {
            var answer = new HashSet<Grouping<TKey, TElement>>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly HashSet<Grouping<TKey, TElement>> ToHashSet(IEqualityComparer<Grouping<TKey, TElement>> comparer)
        {
            var answer = new HashSet<Grouping<TKey, TElement>>(comparer);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly List<Grouping<TKey, TElement>> ToList()
        {
            var answer = new List<Grouping<TKey, TElement>>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }
        #endregion

        #region Sum
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            Grouping<TKey, TElement>
            Sum()
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return default;
            }
            if (typeof(Grouping<TKey, TElement>) == typeof(byte))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, byte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, byte>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<byte, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<sbyte, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, short>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, short>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<short, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, ushort>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, ushort>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<ushort, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, int>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, int>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<int, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, uint>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, uint>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<uint, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, long>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, long>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<long, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, ulong>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, ulong>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<ulong, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, float>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, float>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<float, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, double>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, double>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<double, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, decimal>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<Grouping<TKey, TElement>, decimal>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<decimal, Grouping<TKey, TElement>>(ref sum);
            }
            return default;
        }
        #endregion

        #region Average
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            bool
            TryGetAverage(out Grouping<TKey, TElement> value)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                value = default;
                enumerator.Dispose();
                return false;
            }
            var count = 1L;
            if (typeof(Grouping<TKey, TElement>) == typeof(byte))
            {
                long sum = Unsafe.As<Grouping<TKey, TElement>, byte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, byte>(ref enumerator.Current);
                }
                var val = (byte)(sum / count);
                value = Unsafe.As<byte, Grouping<TKey, TElement>>(ref val);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(sbyte))
            {
                long sum = Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, sbyte>(ref enumerator.Current);
                }
                var val = (sbyte)(sum / count);
                value = Unsafe.As<sbyte, Grouping<TKey, TElement>>(ref val);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(short))
            {
                long sum = Unsafe.As<Grouping<TKey, TElement>, short>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, short>(ref enumerator.Current);
                }
                var val = (short)(sum / count);
                value = Unsafe.As<short, Grouping<TKey, TElement>>(ref val);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ushort))
            {
                long sum = Unsafe.As<Grouping<TKey, TElement>, ushort>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, ushort>(ref enumerator.Current);
                }
                var val = (ushort)(sum / count);
                value = Unsafe.As<ushort, Grouping<TKey, TElement>>(ref val);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(int))
            {
                long sum = Unsafe.As<Grouping<TKey, TElement>, int>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, int>(ref enumerator.Current);
                }
                var val = (int)(sum / count);
                value = Unsafe.As<int, Grouping<TKey, TElement>>(ref val);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(uint))
            {
                long sum = Unsafe.As<Grouping<TKey, TElement>, uint>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, uint>(ref enumerator.Current);
                }
                var val = (uint)(sum / count);
                value = Unsafe.As<uint, Grouping<TKey, TElement>>(ref val);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(long))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, long>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, long>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<long, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(ulong))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, ulong>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, ulong>(ref enumerator.Current);
                }
                sum /= (ulong)count;
                value = Unsafe.As<ulong, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(float))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, float>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, float>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<float, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(double))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, double>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, double>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<double, Grouping<TKey, TElement>>(ref sum);
            }
            else if (typeof(Grouping<TKey, TElement>) == typeof(decimal))
            {
                var sum = Unsafe.As<Grouping<TKey, TElement>, decimal>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<Grouping<TKey, TElement>, decimal>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<decimal, Grouping<TKey, TElement>>(ref sum);
            }
            else
            {
                value = enumerator.Current;
            }
            enumerator.Dispose();
            return true;
        }
        #endregion

        #region OrderByDefault
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultOrderByAscending<Grouping<TKey, TElement>>
            >
            OrderBy(Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DefaultOrderByAscending<Grouping<TKey, TElement>>>(this, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultOrderByDescending<Grouping<TKey, TElement>>
            >
            OrderByDescending(Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, Grouping<TKey, TElement>, DefaultOrderByDescending<Grouping<TKey, TElement>>>(this, default, allocator);
        #endregion

        #region Union Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator, TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat<TEnumerable0, TEnumerator0>(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                    second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                    ConcatEnumerable<
                        GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                        Enumerator,
                        AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                        AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                        Grouping<TKey, TElement>>,
                    ConcatEnumerable<
                        GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                        Enumerator,
                        AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                        AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                        Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultEqualityComparer<Grouping<TKey, TElement>>,
                    DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
                >
                (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union
            (in NativeEnumerable<Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union
            (NativeArray<Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union
            (in ArrayEnumerable<Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union
            (Grouping<TKey, TElement>[]
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer1, TGetHashCodeFunc1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc1 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0, TKey0>
            (in Grouping<TKey0, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TKey0 : unmanaged
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(in second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>,
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                Grouping<TKey, TElement>>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>,
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>,
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>,
                ConcatEnumerable<GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TAction0>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union
            (in RingBuffer<Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TAction0>
            (in SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, ISelectIndex<TPrevSource0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>, TSetOperation0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TEnumerator0,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union
            (in UnrolledLinkedList<Grouping<TKey, TElement>>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    UnrolledLinkedList<Grouping<TKey, TElement>>,
                    UnrolledLinkedList<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>,
                ConcatEnumerable<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                DefaultEqualityComparer<Grouping<TKey, TElement>>,
                DefaultGetHashCodeFunc<Grouping<TKey, TElement>>>
            (Concat(second), default, default, allocator);
        #endregion

        #region Intersect Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect
            (in NativeEnumerable<Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
           (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect
            (NativeArray<Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect
            (in ArrayEnumerable<Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect
            (Grouping<TKey, TElement>[] second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
           (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TKey0>
            (in Grouping<TKey0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer1 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TAction0>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0> second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect
            (in RingBuffer<Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                IntersectOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);
        #endregion

        #region Except Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except
            (in NativeEnumerable<Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
           (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except
            (NativeArray<Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                NativeEnumerable<Grouping<TKey, TElement>>,
                NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    NativeEnumerable<Grouping<TKey, TElement>>,
                    NativeEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except
            (in ArrayEnumerable<Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except
            (Grouping<TKey, TElement>[] second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ArrayEnumerable<Grouping<TKey, TElement>>,
                ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ArrayEnumerable<Grouping<TKey, TElement>>,
                    ArrayEnumerable<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
           (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEnumerator1 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TKey0>
            (in Grouping<TKey0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey0, Grouping<TKey, TElement>>,
                Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    Grouping<TKey0, Grouping<TKey, TElement>>,
                    Grouping<TKey0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<Grouping<TKey, TElement>, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, Grouping<TKey, TElement>>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, Grouping<TKey, TElement>, T0Selector, TEqualityComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TComparer1 : struct, IRefFunc<Grouping<TKey, TElement>, Grouping<TKey, TElement>, int>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TComparer1>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TAction0>
            (in RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0> second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>,
                    RangeRepeatEnumerable<Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except
            (in RingBuffer<Grouping<TKey, TElement>> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                RingBuffer<Grouping<TKey, TElement>>,
                RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    RingBuffer<Grouping<TKey, TElement>>,
                    RingBuffer<Grouping<TKey, TElement>>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IRefFunc<Grouping<TKey, TElement>, bool>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<Grouping<TKey, TElement>>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, Grouping<TKey, TElement>>
            where TPredicate0 : struct, IWhereIndex<Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, Grouping<TKey, TElement>, TPredicate0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, Grouping<TKey, TElement>>
            => new SetOperationEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                Grouping<TKey, TElement>,
                ExceptOperation<
                    GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, Grouping<TKey, TElement>, TAction0>.Enumerator,
                    Grouping<TKey, TElement>,
                    DefaultOrderByAscending<Grouping<TKey, TElement>>
                >
            >
            (this, second, default, allocator);
        #endregion

        #region Join
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TKey1 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1, TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TEqualityComparer1 : struct, IRefFunc<TKey2, TKey2, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey2, TEqualityComparer1>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T1Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            =>
            new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey2, TKey2, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T1Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            =>
            new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<Grouping<TKey, TElement>, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<Grouping<TKey, TElement>, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);
        #endregion

        #region Join Default Func
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TEnumerable0 inner, in Func<Grouping<TKey, TElement>, TKey0> outerKeySelector, in Func<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in NativeEnumerable<T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (NativeArray<T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in ArrayEnumerable<T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (T0[] inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1, TKey0,
                T1
            >
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>
                inner,
                in Func<Grouping<TKey, TElement>, TKey0> outerKeySelector,
                in Func<T0, TKey0> innerKeySelector,
                in Func<Grouping<TKey, TElement>, T0, T1> resultSelector,
                Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TEqualityComparer1 : struct, IRefFunc<TKey2, TKey2, bool>
            where T2Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey2, TEqualityComparer1>
                    >,
                T0>
            where T1 : unmanaged
            =>
            new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TOuterEnumerable0,
                TOuterEnumerator0,
                TOuterSource0,
                TInnerEnumerable0,
                TInnerEnumerator0,
                TInnerSource0,
                TKey2,
                TOuterKeySelector0,
                TInnerKeySelector0,
                T0,
                T2Selector,
                TKeyEqualityComparer0,
                TKey0,
                T1
            >
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>
                inner,
                in Func<Grouping<TKey, TElement>, TKey0> outerKeySelector,
                in Func<T0, TKey0> innerKeySelector,
                in Func<Grouping<TKey, TElement>, T0, T1> resultSelector,
                Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey2, TKey2, bool>
            where T2Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            =>
            new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
            >
            (in RingBuffer<T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
            >
            (in UnrolledLinkedList<T0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged



            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<Grouping<TKey, TElement>, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged



            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<Grouping<TKey, TElement>, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);
        #endregion

        #region Zip Function
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TEnumerable0 second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TResult1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0, TResult1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TKey0, T0, TResult1>
            (in Grouping<TKey0, T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T2, TResult1>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, Func<Grouping<TKey, TElement>, T2, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T2, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T2, TResult1>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, Func<Grouping<TKey, TElement>, T2, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T2, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TComparer0, TResult1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<T0, TAction0, TResult1>
            (in RangeRepeatEnumerable<T0, TAction0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<T0, TResult1>
            (in RingBuffer<T0>
                second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0, TResult1>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0, TResult1>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TEnumerable1, TEnumerator1, TAction0, TResult1>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0, TResult1>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<T0, TResult1>
            (in UnrolledLinkedList<T0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<Grouping<TKey, TElement>, T0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, TResult0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0, TResult1>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            second, Func<Grouping<TKey, TElement>, TResult0, TResult1> action, Grouping<TKey, TElement> firstDefaultValue = default, TResult0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TResult0 : unmanaged
            where TResult1 : unmanaged
            where TAction0 : struct, IRefAction<T0, T1, TResult0>
            => new ZipEnumerable<
                GroupByEnumerable<TEnumerable, TEnumerator, TSource, TKey, TKeySelector, TElement, TElementSelector, TEqualityComparer>,
                Enumerator,
                Grouping<TKey, TElement>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                TResult1,
                DelegateFuncToAction<Grouping<TKey, TElement>, TResult0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);
        #endregion
    }
}