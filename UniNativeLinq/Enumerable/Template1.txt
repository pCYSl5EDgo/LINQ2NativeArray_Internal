#region Interface Implementation
[MethodImpl(MethodImplOptions.AggressiveInlining)]
readonly IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

[MethodImpl(MethodImplOptions.AggressiveInlining)]
readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool CanFastCount() => ;

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Any()
{
    var enumerator = GetEnumerator();
	enumerator.TryGetNext(out var success);
	enumerator.Dispose();
	return success;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly int Count()
    => (int)LongCount();

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly long LongCount()
{
	// var count = 0L;
    // var enumerator = GetEnumerator();
	// bool success;
	// while (true)
	// {
	// enumerator.TryGetNext(out success);
	// if(!success) break;
	// ++count;
	// }
	// enumerator.Dispose();
	// return count;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly void CopyTo(T* dest)
{
    // var enumerator = GetEnumerator();
	// bool success;
	// while(true)
	// {
	// ref var value = ref enumerator.TryGetNext(out success);
	//	if(!success) break;
	// 	*dest++ = value;
	// }
    // enumerator.Dispose();
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly T[] ToArray()
{
    var count = LongCount();
    if(count == 0) return Array.Empty<T>();
    var answer = new T[count];
    CopyTo(Psuedo.AsPointer<T>(ref answer[0]));
    return answer;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly NativeEnumerable<T> ToNativeEnumerable(Allocator allocator)
{
    var count = LongCount();
    var ptr = UnsafeUtilityEx.Malloc<T>(count, allocator);
    CopyTo(ptr);
    return NativeEnumerable<T>.Create(ptr, count);
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly NativeArray<T> ToNativeArray(Allocator allocator)
{
    var count = Count();
    if(count == 0) return default;
    var answer = new NativeArray<T>(count, allocator, NativeArrayOptions.UninitializedMemory);
    CopyTo(UnsafeUtilityEx.GetPointer(answer));
    return answer;
}
#endregion

#region Enumerable
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	AppendEnumerable<
		XYZXYZXYZ,
		Enumerator, 
		T
	>
    Append(T value, Allocator allocator = Allocator.Temp)
    => new AppendEnumerable<
		XYZXYZXYZ,
		Enumerator, 
		T
	>(this, value, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	XYZXYZXYZ 
	AsRefEnumerable()
	=> this;

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	DefaultIfEmptyEnumerable<
		XYZXYZXYZ,
		Enumerator, 
		T
	>
    DefaultIfEmpty(in T defaultValue, Allocator allocator = Allocator.Temp)
    => new DefaultIfEmptyEnumerable<
		XYZXYZXYZ,
		Enumerator, 
		T
	>
	(this, defaultValue, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	DistinctEnumerable<
        XYZXYZXYZ,
        Enumerator,
		T,
		DefaultEqualityComparer<T>,
		DefaultGetHashCodeFunc<T>
	>
    Distinct(Allocator allocator = Allocator.Temp)
    => new DistinctEnumerable<
        XYZXYZXYZ,
        Enumerator,
		T,
		DefaultEqualityComparer<T>,
		DefaultGetHashCodeFunc<T>
	>
	(this, default, default, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	DistinctEnumerable<
        XYZXYZXYZ,
        Enumerator, 
		T,
		TEqualityComparer0,
		TGetHashCodeFunc0
	>
    Distinct<TEqualityComparer0, TGetHashCodeFunc0>
	(in TEqualityComparer0 comparer, in TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        XYZXYZXYZ,
        Enumerator, 
		T,
		TEqualityComparer0,
		TGetHashCodeFunc0
	>
	(this, comparer, getHashCodeFunc, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TComparer0
    >
    OrderBy<TComparer0>(in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TComparer0
    >
	(this, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByFromFunc<T>
    >
    OrderBy(Func<T, T, int> comparer, Allocator allocator = Allocator.Temp)
    => new OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByFromFunc<T>
    >
	(this, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByDescending<T, TComparer0>
    >
    OrderByDescending<TComparer0>(in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByDescending<T, TComparer0>
    >
	(this, comparer, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByDescending<T, OrderByFromFunc<T>>
    >
    OrderByDescending(Func<T, T, int> comparer, Allocator allocator = Allocator.Temp)
    => new OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByDescending<T, OrderByFromFunc<T>>
    >
	(this, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
(
    NativeEnumerable<T> True,
    NativeEnumerable<T> False
)
ToPartition(Func<T, bool> predicate, Allocator allocator = Allocator.Temp)
{
    var True = new NativeList<T>(allocator);
    var False = new NativeList<T>(allocator);
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if(!success) break;
		if (predicate(current))
            True.Add(current);
        else
            False.Add(current);
	}
    enumerator.Dispose();
    return (True.AsNativeEnumerable(), False.AsNativeEnumerable());
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
(
    NativeEnumerable<T> True,
    NativeEnumerable<T> False
)
ToPartition<TPredicate0>(in TPredicate0 predicate, Allocator allocator = Allocator.Temp)
    where TPredicate0 : struct, IRefFunc<T, bool>
{
    var True = new NativeList<T>(allocator);
    var False = new NativeList<T>(allocator);
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var value = ref enumerator.TryGetNext(out success);
		if(!success) break;
		else if (predicate.Calc(ref value))
            True.Add(enumerator.Current);
        else
            False.Add(enumerator.Current);
	}
	enumerator.Dispose();
	return (True.AsNativeEnumerable(), False.AsNativeEnumerable());
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    PrependEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
    Prepend(in T value, Allocator allocator = Allocator.Temp)
    => new PrependEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
	(this, value, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ReverseEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T
	>
    Reverse(Allocator allocator = Allocator.Temp)
    => new ReverseEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T
	>
	(this, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	SelectIndexEnumerable<
		XYZXYZXYZ, 
		Enumerator, 
		T, 
		TNextResult0,
		TNextAction0
	>
    SelectIndex<TNextResult0, TNextAction0>
	(in TNextAction0 action, Allocator allocator = Allocator.Temp)
    where TNextResult0 : unmanaged
    where TNextAction0 : struct, ISelectIndex<T, TNextResult0>
    => new SelectIndexEnumerable<
		XYZXYZXYZ, 
		Enumerator, 
		T, 
		TNextResult0,
		TNextAction0
	>
	(this, action, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	SelectIndexEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T,
		TNextResult0, 
		DelegateFuncToSelectIndexStructOperator<T, TNextResult0>
	>
    SelectIndex<TNextResult0>
	(Func<T, long, TNextResult0> func, Allocator allocator = Allocator.Temp)
    where TNextResult0 : unmanaged
    => new SelectIndexEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T,
		TNextResult0, 
		DelegateFuncToSelectIndexStructOperator<T, TNextResult0>
	>
	(this, func, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
	SelectEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T, 
		TNextResult0,
		TNextAction0
	>
    Select<TNextResult0, TNextAction0>
	(in TNextAction0 action, Allocator allocator = Allocator.Temp)
    where TNextResult0 : unmanaged
    where TNextAction0 : struct, IRefAction<T, TNextResult0>
    => new SelectEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T, 
		TNextResult0,
		TNextAction0
	>
	(this, action, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	SelectEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T,
		TNextResult0, 
		DelegateFuncToAction<T, TNextResult0>
	>
    Select<TNextResult0>(Func<T, TNextResult0> func, Allocator allocator = Allocator.Temp)
    where TNextResult0 : unmanaged
    => new SelectEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T,
		TNextResult0, 
		DelegateFuncToAction<T, TNextResult0>
	>
	(this, func, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TResult0,
        TResultEnumerable0,
        TResultEnumerator0,
        TResultAction
    >
    SelectMany<TResult0, TResultEnumerable0, TResultEnumerator0, TResultAction>
	(in TResultAction action)
    where TResult0 : unmanaged
    where TResultEnumerator0 : struct, IRefEnumerator<TResult0>
    where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TResult0>
    where TResultAction : struct, IRefAction<T, TResultEnumerable0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TResult0,
        TResultEnumerable0,
        TResultEnumerator0,
        TResultAction
    >
	(this, action);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TResult0,
        TResultEnumerable0,
        TResultEnumerator0,
        DelegateFuncToAction<T, TResultEnumerable0>
    >
    SelectMany<TResult0, TResultEnumerable0, TResultEnumerator0>
	(Func<T, TResultEnumerable0> func)
    where TResult0 : unmanaged
    where TResultEnumerator0 : struct, IRefEnumerator<TResult0>
    where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TResult0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TResult0,
        TResultEnumerable0,
        TResultEnumerator0,
        DelegateFuncToAction<T, TResultEnumerable0>
    >
	(this, func);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SkipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
    Skip(long count)
    => new SkipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
	(this, count);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SkipLastEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
    SkipLast(long count, Allocator allocator = Allocator.Temp)
    => new SkipLastEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
	(this, count, allocator);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SkipWhileEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TPredicate0
    >
    SkipWhile<TPredicate0>
	(in TPredicate0 predicate)
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new SkipWhileEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TPredicate0
    >
	(this, predicate);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SkipWhileEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DelegateFuncToStructOperatorFunc<T, bool>
    >
    SkipWhile(Func<T, bool> predicate)
    => new SkipWhileEnumerable<
        NativeEnumerable<T>,
        NativeEnumerable<TSouce>.Enumerator,
        TSouce,
        DelegateFuncToStructOperatorFunc<T, bool>
    >
	(this, predicate);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    TakeEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
    Take(long count)
    => new TakeEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >(this, count);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    TakeWhileEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TPredicate0
    >
    TakeWhile<TPredicate0>(in TPredicate0 predicate)
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new TakeWhileEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TPredicate0
    >
	(this, predicate);

public static
    TakeWhileEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DelegateFuncToStructOperatorFunc<T, bool>
    >
    TakeWhile(Func<T, bool> predicate)
    => new TakeWhileEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DelegateFuncToStructOperatorFunc<T, bool>
    >
	(this, predicate);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    TakeLastEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
    TakeLast(long count, Allocator allocator = Allocator.Temp)
    => new TakeLastEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T
    >
	(this, count, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	SelectIndexEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T,
		(T, long),
		WithIndex<T>
	>
	WithIndex(Allocator allocator = Allocator.Temp)
	=> new SelectIndexEnumerable<
		XYZXYZXYZ,
		Enumerator,
		T,
		(T, long),
		WithIndex<T>
	>
	(this, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    WhereEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TPredicate0
    >
    Where<TPredicate0>(in TPredicate0 predicate)
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new WhereEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TPredicate0
    >
	(this, predicate);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    WhereEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DelegateFuncToStructOperatorFunc<T, bool>
    >
    Where(Func<T, bool> predicate)
    => new WhereEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DelegateFuncToStructOperatorFunc<T, bool>
    >
	(this, predicate);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    WhereIndexEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TPredicate0
    >
    WhereIndex<TPredicate0>(in TPredicate0 predicate)
    where TPredicate0 : struct, IWhereIndex<T>
    => new WhereIndexEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TPredicate0
    >
	(this, predicate);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    WhereIndexEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DelegateFuncToWhereIndexStructOperator<T>
    >
    WhereIndex(Func<T, long, bool> predicate)
    => new WhereIndexEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DelegateFuncToWhereIndexStructOperator<T>
    >(this, predicate);
#endregion

#region Concat
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TEnumerable1,
        TEnumerator1,
        T
    >
    Concat<TEnumerable1, TEnumerator1>
    (in TEnumerable1 second)
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TEnumerable1, TEnumerator1,
        T
    >
    (this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T>,
        ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T>.Enumerator,
        T
    >
    Concat<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2>
    (in ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T> second)
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable2 : struct, IRefEnumerable<TEnumerator2, T>
    where TEnumerator2 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T>,
        ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T>.Enumerator,
        T
    >
	(this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T
    >
    Concat(NativeArray<T> second)
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T
    >
	(this, NativeEnumerable.AsRefEnumerable(second));
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T
    >
    Concat(in NativeEnumerable<T> second)
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T
    >
	(this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        AppendEnumerable<TEnumerable1, TEnumerator1, T>,
        AppendEnumerable<TEnumerable1, TEnumerator1, T>.Enumerator,
        T
    >
    Concat<TEnumerable1, TEnumerator1>
    (in AppendEnumerable<TEnumerable1, TEnumerator1, T> second)
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        AppendEnumerable<TEnumerable1, TEnumerator1, T>,
        AppendEnumerable<TEnumerable1, TEnumerator1, T>.Enumerator,
        T
    >
	(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T
    >
    Concat(in ArrayEnumerable<T> second)
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T
    >
	(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T
    >
    Concat(in T[] second)
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T
    >
	(this, NativeEnumerable.AsRefEnumerable(second));

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T>,
        DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T>.Enumerator,
        T
    >
    Concat<TEnumerable1, TEnumerator1>
    (in DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T> second)
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T>,
        DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T>.Enumerator,
        T
    >
	(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T
    >
    Concat<TEnumerable1, TEnumerator1, TEqualityComparer0, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0> second)
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T
    >
	(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T
    >
    Concat<TKey0>
    (in Grouping<TKey0, T> second)
    where TKey0 : unmanaged
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T
    >
	(this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T
    >
    Concat<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0Selector, TKeyEqualityComparer0>
    (in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>
    second)
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where TKey0 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
    where T0Selector : struct,
    IRefFunc<TOuterSource0,
        WhereIndexEnumerable<
            NativeEnumerable<TInnerSource0>,
            NativeEnumerable<TInnerSource0>.Enumerator,
            TInnerSource0,
            GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
            >,
        T>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T
    >(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer0>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0> second)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0>.Enumerator,
        T
    >(this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0, TComparer0>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
        T
    >(this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >(this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        RangeRepeatEnumerable<T, TAction1>,
        RangeRepeatEnumerable<T, TAction1>.Enumerator,
        T
    >
    Concat<TAction1>
    (in RangeRepeatEnumerable<T, TAction1> second)
    where TAction1 : struct, IRangeRepeat<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        RangeRepeatEnumerable<T, TAction1>,
        RangeRepeatEnumerable<T, TAction1>.Enumerator,
        T
    >(this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >(this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1>,
        SelectEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1>.Enumerator,
        T
    >
    Concat<TEnumerable1, TEnumerator1, TPrev1, TAction1>
    (in SelectEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1> second)
    where TEnumerator1 : struct, IRefEnumerator<TPrev1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TPrev1>
    where TAction1 : struct, IRefAction<TPrev1, T>
    where TPrev1 : unmanaged
    => new ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1>,
            SelectEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1>.Enumerator,
            T>
        (this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1>,
        SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1>.Enumerator,
        T
    >
    Concat<TEnumerable1, TEnumerator1, TPrev1, TAction1>
    (in SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1> second)
    where TEnumerator1 : struct, IRefEnumerator<TPrev1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TPrev1>
    where TAction1 : struct, ISelectIndex<TPrev1, T>
    where TPrev1 : unmanaged
    => new ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1>,
            SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrev1, T, TAction1>.Enumerator,
            T>
        (this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T, TResultEnumerable0, TResultEnumerator0, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T, TResultEnumerable0, TResultEnumerator0, TAction0>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0, TPrev0, TResultEnumerable0, TResultEnumerator0, TAction0>
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T, TResultEnumerable0, TResultEnumerator0, TAction0> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TPrev0 : unmanaged
    where TResultEnumerator0 : struct, IRefEnumerator<T>
    where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, T>
    where TAction0 : struct, IRefAction<TPrev0, TResultEnumerable0>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T, TResultEnumerable0, TResultEnumerator0, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T, TResultEnumerable0, TResultEnumerator0, TAction0>.Enumerator,
        T
    >(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
    (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
        T
    >(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipEnumerable<TEnumerable0, TEnumerator0, T>,
        TEnumerator0,
        T
    >
    Concat<TEnumerable0, TEnumerator0>(in SkipEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipEnumerable<TEnumerable0, TEnumerator0, T>,
        TEnumerator0,
        T
    >
    (this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0>(in TakeEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >
    (this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TEnumerator0,
        T
    >
    Concat<TEnumerable0, TEnumerator0, TPredicate0>(in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TEnumerator0,
        T
    >
    (this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0, TPredicate0>(in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T
    >
    (this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0>(in SkipLastEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >
    (this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0>(in TakeLastEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T
    >
    (this, second);
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0, TPredicate0>(in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TPredicate0 :  struct, IRefFunc<T, bool>
    => new ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T
    >(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0>.Enumerator,
        T
    >
    Concat<TPrevEnumerable0, TPrevEnumerator0, TPredicate0>
    (in WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0> second)
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, T>
    where TPrevEnumerator0 : struct, IRefEnumerator<T>
    where TPredicate0 :  struct, IWhereIndex<T>
    => new ConcatEnumerable<XYZXYZXYZ, Enumerator, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0>.Enumerator, T>(this, second);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly ConcatEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        T
    >
    Concat<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => new ConcatEnumerable<XYZXYZXYZ, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T>(this, second);
#endregion

#region Except
[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TEnumerable0,
        TEnumerator0,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TEnumerable0,
            TEnumerator0,
            T,
            TComparer0
        >
    >
    Except<TEnumerable0, TEnumerator0, TComparer0>
    (in TEnumerable0 second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, TEnumerable0, TEnumerator0, T, ExceptOperation<XYZXYZXYZ, Enumerator, TEnumerable0, TEnumerator0, T, TComparer0>>
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TEnumerable0, TEnumerator0, TComparer0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, T>, AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, T>, AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0>
    (in NativeEnumerable<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0>
    (NativeArray<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, TComparer0>>
        (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0>
    (in ArrayEnumerable<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0>
    (T[] second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, TComparer0>>
    (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TKey0, TComparer0>
    (in Grouping<TKey0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TKey0: unmanaged
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
    second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct,
    IRefFunc<T0,
        WhereIndexEnumerable<
            NativeEnumerable<T1>,
            NativeEnumerable<T1>.Enumerator,
            T1,
            GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
            >,
        T>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >
    >(this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
    second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >
    >(this, second, new ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >(comparer), allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, TComparer1>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer1 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, T>, PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, T>, PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        RangeRepeatEnumerable<T, TAction0>,
        RangeRepeatEnumerable<T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TAction0>
    (in RangeRepeatEnumerable<T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TAction0 : struct, IRangeRepeat<T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, RangeRepeatEnumerable<T, TAction0>, RangeRepeatEnumerable<T, TAction0>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, RangeRepeatEnumerable<T, TAction0>, RangeRepeatEnumerable<T, TAction0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, T>, ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, T>, ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TAction0 : struct, IRefAction<T0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TAction0 : struct, ISelectIndex<T0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipEnumerable<TEnumerable0, TEnumerator0, T>,
        TEnumerator0,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0>
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipEnumerable<TEnumerable0, TEnumerator0, T>,
        TEnumerator0,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T,
            TComparer0
        >
    >
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0>
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TEnumerator0,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TEnumerator0,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T,
            TComparer0
        >
    >
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            TComparer0
        >
    >
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0>
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0>
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, TComparer0>>
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IWhereIndex<T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T,
            TComparer0
        >
    >
    Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T, ExceptOperation<XYZXYZXYZ, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);
#endregion

#region GroupJoin
[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            TEnumerable0,
            TEnumerator0,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            NativeEnumerable<T0>,
            NativeEnumerable<T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            NativeEnumerable<T0>,
            NativeEnumerable<T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            ArrayEnumerable<T0>,
            ArrayEnumerable<T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            ArrayEnumerable<T0>,
            ArrayEnumerable<T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEnumerable1, TEnumerator1
    >
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEqualityComparer1, TGetHashCodeFunc0
    >
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey1, T0>,
        Grouping<TKey1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        TKey1,
        T1,
        T0Selector,
        TEqualityComparer0
    >(in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TKey1 : unmanaged
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey1, T0>,
        Grouping<TKey1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEnumerable1, TEnumerator1, TSetOperation0
    >
    (in SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        > inner,
    in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1
    >
    GroupJoin<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1>
    (
        in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
        inner,
        in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
        in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
    )
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where T0 : unmanaged
    where TKey0 : unmanaged
    where TKey1 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct,
    IRefFunc<TOuterSource0,
        WhereIndexEnumerable<
            NativeEnumerable<TInnerSource0>,
            NativeEnumerable<TInnerSource0>.Enumerator,
            TInnerSource0,
            GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
            >,
        T0>
    where T1 : unmanaged
    where TOuterKeySelector1 : struct, IRefFunc<T, TKey1>
    where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
    where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
    where T1Selector : struct,
    IRefFunc<T,
        WhereIndexEnumerable<
            NativeEnumerable<T0>,
            NativeEnumerable<T0>.Enumerator,
            T0,
            GroupJoinPredicate<T0, TKey1, TKeyEqualityComparer1>
            >,
        T1>
    =>
    new GroupJoinEnumerable
    <
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1
    >(this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable
    <
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1
    >
    GroupJoin<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1>
    (
        in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
        inner,
        in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
        in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
    )
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where T0 : unmanaged
    where TKey0 : unmanaged
    where TKey1 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
    where T1 : unmanaged
    where TOuterKeySelector1 : struct, IRefFunc<T, TKey1>
    where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
    where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
    where T1Selector : struct,
    IRefFunc<T,
        WhereIndexEnumerable<
            NativeEnumerable<T0>,
            NativeEnumerable<T0>.Enumerator,
            T0,
            GroupJoinPredicate<T0, TKey1, TKeyEqualityComparer1>
            >,
        T1>
    =>
    new GroupJoinEnumerable
    <
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TComparer0
    >
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TComparer0 : struct, IRefFunc<T0, T0, int>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            RangeRepeatEnumerable<T0, TAction0>,
            RangeRepeatEnumerable<T0, TAction0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TAction0
    >
    (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TAction0 : struct, IRangeRepeat<T0>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, RangeRepeatEnumerable<T0, TAction0>, RangeRepeatEnumerable<T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPrev0, TAction0
    >
    (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TAction0 : struct, IRefAction<TPrev0, T0>
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPrev0, TAction0
    >
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TAction0 : struct, ISelectIndex<TPrev0, T0>
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEnumerable1, TEnumerator1, TPrev0, TAction0
    >
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TAction0 : struct, IRefAction<TPrev0, TEnumerable1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPredicate0
    >
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPredicate0
    >
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new GroupJoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPredicate0
    >
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPredicate0
    >
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TPredicate0 : struct, IWhereIndex<T0>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    GroupJoinEnumerable<
            XYZXYZXYZ,
            Enumerator,
            T,
            ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
            T0,
            TKey0,
            TKeySelector0,
            TKeySelector1,
            T1,
            T0Selector,
            TEqualityComparer0
        >
    GroupJoin<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEnumerable1, TEnumerator1, T2, T3, TAction0
    >
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where T3 : unmanaged
    where TAction0 : struct, IRefAction<T2, T3, T0>
    where TEnumerator0 : struct, IRefEnumerator<T2>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEnumerator1 : struct, IRefEnumerator<T3>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
    => new GroupJoinEnumerable<XYZXYZXYZ, Enumerator, T, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);
#endregion

#region Intersect
[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TEnumerable0,
        TEnumerator0,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            TEnumerable0,
            TEnumerator0,
            T,
            TComparer0
        >
    >
    Intersect<TEnumerable0, TEnumerator0, TComparer0>
    (in TEnumerable0 second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, TEnumerable0, TEnumerator0, T, IntersectOperation<XYZXYZXYZ, Enumerator, TEnumerable0, TEnumerator0, T, TComparer0>>
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TEnumerable0, TEnumerator0, TComparer0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, T>, AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, T>, AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0>
    (in NativeEnumerable<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0>
    (NativeArray<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, TComparer0>>
        (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0>
    (in ArrayEnumerable<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0>
    (T[] second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, TComparer0>>
        (this, NativeEnumerable.AsRefEnumerable(second), comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TKey0, TComparer0>
    (in Grouping<TKey0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TKey0: unmanaged
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
    second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct,
    IRefFunc<T0,
        WhereIndexEnumerable<
            NativeEnumerable<T1>,
            NativeEnumerable<T1>.Enumerator,
            T1,
            GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
            >,
        T>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >
    >(this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
    second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            TComparer0
        >
    >(this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, TComparer1>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer1 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, T>, PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, T>, PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        RangeRepeatEnumerable<T, TAction0>,
        RangeRepeatEnumerable<T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TAction0>
    (in RangeRepeatEnumerable<T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TAction0 : struct, IRangeRepeat<T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, RangeRepeatEnumerable<T, TAction0>, RangeRepeatEnumerable<T, TAction0>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, RangeRepeatEnumerable<T, TAction0>, RangeRepeatEnumerable<T, TAction0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, T>, ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, T>, ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TAction0 : struct, IRefAction<T0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, TComparer0>>
    (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TAction0 : struct, ISelectIndex<T0, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IWhereIndex<T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T,
            TComparer0
        >
    >
    Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TComparer0 : struct, IRefFunc<T, T, int>
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => new SetOperationEnumerable<XYZXYZXYZ, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T, IntersectOperation<XYZXYZXYZ, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T, TComparer0>>
        (this, second, comparer, allocator);
#endregion

#region Join
[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEnumerable1, TEnumerator1
    >
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEqualityComparer1, TGetHashCodeFunc0
    >
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey1, T0>,
        Grouping<TKey1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TKey1
    >
    (in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TKey1 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey1, T0>,
        Grouping<TKey1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEnumerable1, TEnumerator1, TSetOperation0
    >
    (in SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        > inner,
    in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1
    >
    Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1>
    (
        in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
        inner,
        in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
        in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
    )
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where T0 : unmanaged
    where TKey0 : unmanaged
    where TKey1 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct,
    IRefFunc<TOuterSource0,
        WhereIndexEnumerable<
            NativeEnumerable<TInnerSource0>,
            NativeEnumerable<TInnerSource0>.Enumerator,
            TInnerSource0,
            GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
            >,
        T0>
    where T1 : unmanaged
    where TOuterKeySelector1 : struct, IRefFunc<T, TKey1>
    where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
    where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
    where T1Selector : struct, IRefFunc<T, T0, T1>
    =>
    new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1
    >(this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1
    >
    Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1>
    (
        in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
        inner,
        in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
        in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
    )
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where T0 : unmanaged
    where TKey0 : unmanaged
    where TKey1 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
    where T1 : unmanaged
    where TOuterKeySelector1 : struct, IRefFunc<T, TKey1>
    where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
    where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
    where T1Selector : struct, IRefFunc<T, T0, T1>
    =>
    new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey1,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        TKeyEqualityComparer1
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TComparer0
    >
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TComparer0 : struct, IRefFunc<T0, T0, int>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TAction0
    >
    (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TAction0 : struct, IRangeRepeat<T0>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, RangeRepeatEnumerable<T0, TAction0>, RangeRepeatEnumerable<T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPrev0, TAction0
    >
    (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TAction0 : struct, IRefAction<TPrev0, T0>
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPrev0, TAction0
    >
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TAction0 : struct, ISelectIndex<TPrev0, T0>
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEnumerable1, TEnumerator1, TPrev0, TAction0
    >
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TAction0 : struct, IRefAction<TPrev0, TEnumerable1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPredicate0
    >
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPredicate0
    >
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
    >
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPredicate0
    >
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TPredicate0
    >
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TPredicate0 : struct, IWhereIndex<T0>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        TEqualityComparer0
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
        , TEnumerable1, TEnumerator1, T2, T3, TAction0
    >
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where T3 : unmanaged
    where TAction0 : struct, IRefAction<T2, T3, T0>
    where TEnumerator0 : struct, IRefEnumerator<T2>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TEnumerator1 : struct, IRefEnumerator<T3>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
    => new JoinEnumerable<XYZXYZXYZ, Enumerator, T, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);
#endregion

#region Max
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool TryGetMax(out T value)
{
    value = default;
    if (typeof(T) == typeof(byte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, byte>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, byte>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(sbyte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, sbyte>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, sbyte>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(short))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, short>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, short>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(ushort))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, ushort>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, ushort>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(int))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, int>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, int>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(uint))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, uint>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, uint>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(long))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, long>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, long>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(ulong))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, ulong>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, ulong>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(float))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, float>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, float>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(double))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, double>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, double>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(decimal))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, decimal>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, decimal>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(byte?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, byte?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, byte?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(sbyte?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, sbyte?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, sbyte?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(short?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, short?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, short?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(ushort?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, ushort?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, ushort?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(int?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, int?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, int?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(uint?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, uint?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, uint?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(long?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, long?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, long?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(ulong?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, ulong?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, ulong?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(float?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, float?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, float?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(double?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, double?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, double?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(decimal?))
    {
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, decimal?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, decimal?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return true;
    }
    else
    {
        return false;
    }
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly T Max()
{
    T value;
    if (typeof(T) == typeof(byte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, byte>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, byte>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(sbyte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, sbyte>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, sbyte>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(short))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, short>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, short>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(ushort))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, ushort>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, ushort>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(int))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, int>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, int>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(uint))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, uint>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, uint>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(long))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, long>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, long>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(ulong))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, ulong>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, ulong>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(float))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, float>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, float>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(double))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, double>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, double>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(decimal))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, decimal>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, decimal>(ref current) > max)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(decimal?))
    {
        var enumerator = GetEnumerator();
    INITIALIZE:
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var max = ref Psuedo.As<T, decimal?>(ref value);
        if (!max.HasValue) goto INITIALIZE;
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, decimal?>(ref enumerator.Current);
            if (!current.HasValue || current.Value <= max.Value) continue;
            max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(byte?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, byte?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, byte?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(sbyte?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, sbyte?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, sbyte?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(short?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, short?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, short?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(ushort?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, ushort?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, ushort?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(int?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, int?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, int?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(uint?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, uint?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, uint?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(long?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, long?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, long?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(ulong?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, ulong?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, ulong?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(float?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, float?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, float?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(double?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, double?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, double?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(decimal?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var max = ref Psuedo.As<T, decimal?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!max.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, decimal?>(ref enumerator.Current);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        enumerator.Dispose();
        return value;
    }
    else
    {
        throw new InvalidOperationException();
    }
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public bool TryGetMax<TResult0>(Func<T, TResult0> func, out TResult0 value)
    where TResult0 : unmanaged
{
    value = default;
    if (typeof(TResult0) == typeof(byte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, byte>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, byte>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(byte?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, byte?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, byte?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(sbyte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, sbyte>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, sbyte>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(sbyte?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, sbyte?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, sbyte?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(short))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, short>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, short>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(short?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, short?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, short?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(ushort))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, ushort>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ushort>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(ushort?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, ushort?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ushort?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(int))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, int>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, int>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(int?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, int?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, int?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(uint))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, uint>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, uint>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(uint?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, uint?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, uint?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(long))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, long>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, long>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(long?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, long?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, long?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(ulong))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, ulong>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ulong>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(ulong?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, ulong?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ulong?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(float))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, float>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, float>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(float?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, float?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, float?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(double))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, double>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, double>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(double?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, double?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, double?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(decimal))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, decimal>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, decimal>(ref result);
            if (current > max)
                max = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(decimal?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, decimal?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, decimal?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return true;
    }
    else
    {
        return false;
    }
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public TResult0 Max<TResult0>(Func<T, TResult0> func)
    where TResult0 : unmanaged
{
    TResult0 value = default;
    if (typeof(TResult0) == typeof(byte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, byte>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, byte>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(byte?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, byte?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, byte?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(sbyte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, sbyte>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, sbyte>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(sbyte?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, sbyte?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, sbyte?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(short))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, short>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, short>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(short?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, short?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, short?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(ushort))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, ushort>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ushort>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(ushort?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, ushort?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ushort?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(int))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, int>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, int>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(int?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, int?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, int?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(uint))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, uint>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, uint>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(uint?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, uint?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, uint?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(long))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, long>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, long>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(long?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, long?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, long?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(ulong))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, ulong>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ulong>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(ulong?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, ulong?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ulong?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(float))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, float>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, float>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(float?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, float?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, float?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(double))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, double>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, double>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(double?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, double?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, double?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(decimal))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, decimal>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, decimal>(ref result);
            if (current > max)
                max = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(decimal?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var max = ref Psuedo.As<TResult0, decimal?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, decimal?>(ref result);
            if (current.HasValue && current.Value > max.Value)
                max = current;
        }
        return value;
    }
    else
    {
        throw new InvalidOperationException();
    }
}
#endregion

#region Min
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool TryGetMin(out T value)
{
    value = default;
    if (typeof(T) == typeof(byte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, byte>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, byte>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(sbyte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, sbyte>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, sbyte>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(short))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, short>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, short>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(ushort))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, ushort>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, ushort>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(int))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, int>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, int>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(uint))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, uint>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, uint>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(long))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, long>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, long>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(ulong))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, ulong>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, ulong>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(float))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, float>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, float>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(double))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, double>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, double>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(decimal))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, decimal>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, decimal>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(byte?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, byte?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, byte?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(sbyte?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, sbyte?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, sbyte?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(short?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, short?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, short?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(ushort?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, ushort?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, ushort?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(int?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, int?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, int?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(uint?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, uint?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, uint?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(long?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, long?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, long?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(ulong?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, ulong?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, ulong?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(float?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, float?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, float?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(double?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, double?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, double?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else if (typeof(T) == typeof(decimal?))
    {
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, decimal?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, decimal?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return true;
    }
    else
    {
        return false;
    }
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly T Min()
{
    T value;
    if (typeof(T) == typeof(byte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, byte>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, byte>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(sbyte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, sbyte>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, sbyte>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(short))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, short>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, short>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(ushort))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, ushort>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, ushort>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(int))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, int>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, int>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(uint))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, uint>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, uint>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(long))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, long>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, long>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(ulong))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, ulong>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, ulong>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(float))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, float>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, float>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(double))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, double>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, double>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(decimal))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, decimal>(ref value);
        while (enumerator.MoveNext())
        {
            var current = enumerator.Current;
            if (Psuedo.As<T, decimal>(ref current) < min)
                value = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(decimal?))
    {
        var enumerator = GetEnumerator();
    INITIALIZE:
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = enumerator.Current;
        ref var min = ref Psuedo.As<T, decimal?>(ref value);
        if (!min.HasValue) goto INITIALIZE;
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, decimal?>(ref enumerator.Current);
            if (!current.HasValue || current.Value <= min.Value) continue;
            min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(byte?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, byte?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, byte?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(sbyte?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, sbyte?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, sbyte?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(short?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, short?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, short?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(ushort?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, ushort?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, ushort?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(int?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, int?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, int?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(uint?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, uint?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, uint?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(long?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, long?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, long?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(ulong?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, ulong?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, ulong?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(float?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, float?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, float?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(double?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, double?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, double?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else if (typeof(T) == typeof(decimal?))
    {
        value = default;
        var enumerator = GetEnumerator();
        ref var min = ref Psuedo.As<T, decimal?>(ref value);
        do
        {
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            value = enumerator.Current;
        } while (!min.HasValue);
        while (enumerator.MoveNext())
        {
            var current = Psuedo.As<T, decimal?>(ref enumerator.Current);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        enumerator.Dispose();
        return value;
    }
    else
    {
        throw new InvalidOperationException();
    }
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public bool TryGetMin<TResult0>(Func<T, TResult0> func, out TResult0 value)
    where TResult0 : unmanaged
{
    value = default;
    if (typeof(TResult0) == typeof(byte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, byte>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, byte>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(byte?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, byte?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, byte?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(sbyte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, sbyte>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, sbyte>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(sbyte?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, sbyte?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, sbyte?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(short))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, short>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, short>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(short?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, short?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, short?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(ushort))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, ushort>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ushort>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(ushort?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, ushort?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ushort?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(int))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, int>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, int>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(int?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, int?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, int?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(uint))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, uint>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, uint>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(uint?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, uint?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, uint?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(long))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, long>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, long>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(long?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, long?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, long?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(ulong))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, ulong>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ulong>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(ulong?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, ulong?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ulong?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(float))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, float>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, float>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(float?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, float?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, float?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(double))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, double>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, double>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(double?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, double?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, double?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    if (typeof(TResult0) == typeof(decimal))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, decimal>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, decimal>(ref result);
            if (current < min)
                min = current;
        }
        return true;
    }
    else if (typeof(TResult0) == typeof(decimal?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            return false;
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, decimal?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, decimal?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return true;
    }
    else
    {
        return false;
    }
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public TResult0 Min<TResult0>(Func<T, TResult0> func)
    where TResult0 : unmanaged
{
    TResult0 value = default;
    if (typeof(TResult0) == typeof(byte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, byte>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, byte>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(byte?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, byte?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, byte?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(sbyte))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, sbyte>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, sbyte>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(sbyte?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, sbyte?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, sbyte?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(short))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, short>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, short>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(short?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, short?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, short?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(ushort))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, ushort>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ushort>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(ushort?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, ushort?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ushort?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(int))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, int>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, int>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(int?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, int?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, int?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(uint))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, uint>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, uint>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(uint?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, uint?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, uint?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(long))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, long>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, long>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(long?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, long?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, long?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(ulong))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, ulong>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ulong>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(ulong?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, ulong?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, ulong?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(float))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, float>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, float>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(float?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, float?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, float?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(double))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, double>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, double>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(double?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, double?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, double?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    if (typeof(TResult0) == typeof(decimal))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, decimal>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, decimal>(ref result);
            if (current < min)
                min = current;
        }
        return value;
    }
    else if (typeof(TResult0) == typeof(decimal?))
    {
        var enumerator = GetEnumerator();
        if (!enumerator.MoveNext())
        {
            enumerator.Dispose();
            throw new InvalidOperationException();
        }
        value = func(enumerator.Current);
        ref var min = ref Psuedo.As<TResult0, decimal?>(ref value);
        while (enumerator.MoveNext())
        {
            var result = func(enumerator.Current);
            ref var current = ref Psuedo.As<TResult0, decimal?>(ref result);
            if (current.HasValue && current.Value < min.Value)
                min = current;
        }
        return value;
    }
    else
    {
        throw new InvalidOperationException();
    }
}
#endregion

#region Min Max
public
    MinMaxByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        MinByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
        DefaultEqualityComparer<TKey0>
    >
    MinBy<TKey0>(Func<T, TKey0> func)
    where TKey0 : unmanaged
    => new MinMaxByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        MinByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
        DefaultEqualityComparer<TKey0>
    >
    (this, func, default, default);

public
    MinMaxByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        MaxByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
        DefaultEqualityComparer<TKey0>
    >
    MaxBy<TKey0>(Func<T, TKey0> func)
    where TKey0 : unmanaged
    => new MinMaxByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        MaxByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
        DefaultEqualityComparer<TKey0>
    >
    (this, func, default, default);
#endregion

#region Union
[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator, TEnumerable0, TEnumerator0, T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator, TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in TEnumerable0 second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<ConcatEnumerable<XYZXYZXYZ, Enumerator, TEnumerable0, TEnumerator0, T>, ConcatEnumerable<XYZXYZXYZ, Enumerator, TEnumerable0, TEnumerator0, T>.Enumerator, T, TEqualityComparer0, TGetHashCodeFunc0>
        (Concat<TEnumerable0, TEnumerator0>(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator, 
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T>
            second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEqualityComparer0, TGetHashCodeFunc0>
    (in NativeEnumerable<T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
	>
    Union<TEqualityComparer0, TGetHashCodeFunc0>
    (NativeArray<T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
	>
    (Concat(NativeEnumerable.AsRefEnumerable(second)), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEqualityComparer0, TGetHashCodeFunc0>
    (in ArrayEnumerable<T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEqualityComparer0, TGetHashCodeFunc0>
    (T[]
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(NativeEnumerable.AsRefEnumerable(second)), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, TGetHashCodeFunc0>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TEqualityComparer1, TGetHashCodeFunc1>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TEqualityComparer1 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc1 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TKey0>
    (in Grouping<TKey0, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    (Concat(in second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<XYZXYZXYZ, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
        ConcatEnumerable<XYZXYZXYZ, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where T0Selector : struct,
    IRefFunc<T0,
        WhereIndexEnumerable<
            NativeEnumerable<T1>,
            NativeEnumerable<T1>.Enumerator,
            T1,
            GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
            >,
        T>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new DistinctEnumerable<
        ConcatEnumerable<XYZXYZXYZ, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
        ConcatEnumerable<XYZXYZXYZ, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<XYZXYZXYZ, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
        ConcatEnumerable<XYZXYZXYZ, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool> 
    => new DistinctEnumerable<
        ConcatEnumerable<XYZXYZXYZ, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
        ConcatEnumerable<XYZXYZXYZ, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TComparer0>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TAction0, TEqualityComparer0, TGetHashCodeFunc0>
    (in RangeRepeatEnumerable<T, TAction0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TAction0 : struct, IRangeRepeat<T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TPrevEnumerable0, TPrevEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPrev0, TAction0>
    (in SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TPrevEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrev0>
    where TAction0 : struct, IRefAction<TPrev0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TPrevEnumerable0, TPrevEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPrev0, TAction0>
    (in SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TPrevEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrev0>
    where TAction0 : struct, ISelectIndex<TPrev0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, T0, TEnumerable1, TEnumerator1, TAction0>
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TAction0 : struct, IRefAction<T0, TEnumerable1>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TEnumerable1, TEnumerator1, TSetOperation0>
    (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
    => new DistinctEnumerable<ConcatEnumerable<XYZXYZXYZ, Enumerator, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator, T>, ConcatEnumerable<XYZXYZXYZ, Enumerator, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator, T>.Enumerator, T, TEqualityComparer0, TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0
    >
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IWhereIndex<T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>
        second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        TEqualityComparer0,
        TGetHashCodeFunc0>
    (Concat(second), comparer, getHashCodeFunc, allocator);
#endregion

#region SequenceEqual
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in TEnumerable0 second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
{
    var enumerator0 = GetEnumerator();
    var enumerator1 = second.GetEnumerator();
    while (true)
    {
        var b = enumerator0.MoveNext();
        if (b ^ enumerator1.MoveNext())
        {
            enumerator0.Dispose();
            enumerator1.Dispose();
            return false;
        }
        if (!b)
        {
            enumerator0.Dispose();
            enumerator1.Dispose();
            return true;
        }
        if (!comparer.Calc(ref enumerator0.Current, ref enumerator1.Current)) return false;
    }
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0>
    (in TEnumerable0 second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => SequenceEqual<
        TEnumerable0, TEnumerator0,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => SequenceEqual<
        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEqualityComparer0>
    (in NativeEnumerable<T> second, in TEqualityComparer0 comparer)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual(in NativeEnumerable<T> second)
    => SequenceEqual<
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEqualityComparer0>
    (in NativeArray<T> second, in TEqualityComparer0 comparer)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        TEqualityComparer0
    >(NativeEnumerable.AsRefEnumerable(second), comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual(in NativeArray<T> second)
    => SequenceEqual<
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        DefaultEqualityComparer<T>
    >(NativeEnumerable.AsRefEnumerable(second), default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEqualityComparer0>
    (in ArrayEnumerable<T> second, in TEqualityComparer0 comparer)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual(in ArrayEnumerable<T> second)
    => SequenceEqual<
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEqualityComparer0>
    (T[] second, in TEqualityComparer0 comparer)
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        TEqualityComparer0
    >(NativeEnumerable.AsRefEnumerable(second), comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual(T[] second)
    => SequenceEqual<
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        DefaultEqualityComparer<T>
    >(NativeEnumerable.AsRefEnumerable(second), default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    => SequenceEqual<
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => SequenceEqual<
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TEqualityComparer1, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TEqualityComparer1 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => SequenceEqual<
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEqualityComparer0, TKey0>
    (in Grouping<TKey0, T> second, in TEqualityComparer0 comparer)
    where TKey0 : unmanaged
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        TEqualityComparer0
    >
    (second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer1, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer1 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => SequenceEqual<
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1> second, in TEqualityComparer0 comparer)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    => SequenceEqual<
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1> second, in TEqualityComparer0 comparer)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct,
    IRefFunc<T0,
        WhereIndexEnumerable<
            NativeEnumerable<T1>,
            NativeEnumerable<T1>.Enumerator,
            T1,
            GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
            >,
        T>
    => SequenceEqual<
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1> second)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    => SequenceEqual<
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TComparer0>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => SequenceEqual<
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TComparer0>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => SequenceEqual<
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => SequenceEqual<
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEqualityComparer0, TAction0>
    (in RangeRepeatEnumerable<T, TAction0> second, in TEqualityComparer0 comparer)
    where TAction0 : struct, IRangeRepeat<T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        RangeRepeatEnumerable<T, TAction0>,
        RangeRepeatEnumerable<T, TAction0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TAction0>
    (in RangeRepeatEnumerable<T, TAction0> second)
    where TAction0 : struct, IRangeRepeat<T>
    => SequenceEqual<

        RangeRepeatEnumerable<T, TAction0>,
        RangeRepeatEnumerable<T, TAction0>.Enumerator,

        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => SequenceEqual<
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, T0, TAction0>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T0, T>
    => SequenceEqual<
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second)
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T0, T>
    => SequenceEqual<
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, T0, TAction0>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where T0 : unmanaged
    where TAction0 : struct, ISelectIndex<T0, T>
    => SequenceEqual<
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second)
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T0 : unmanaged
    where TAction0 : struct, ISelectIndex<T0, T>
    => SequenceEqual<
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, T0, TAction0>
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T0, TEnumerable1>
    => SequenceEqual<
        SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TAction0>
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0> second)
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T0, TEnumerable1>
    => SequenceEqual<
        SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, TSetOperation0>
    (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
    => SequenceEqual<
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
    (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
    => SequenceEqual<
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        SkipEnumerable<TEnumerable0, TEnumerator0, T>,
        TEnumerator0,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        TakeEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => SequenceEqual<
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TEnumerator0,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => SequenceEqual<
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    => SequenceEqual<
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => SequenceEqual<
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => SequenceEqual<
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TEqualityComparer0 comparer)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TPredicate0 : struct, IWhereIndex<T>
    => SequenceEqual<
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IWhereIndex<T>
    => SequenceEqual<
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, T0, T1, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, in TEqualityComparer0 comparer)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => SequenceEqual<
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        TEqualityComparer0
    >(second, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool
    SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, T1, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => SequenceEqual<
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        DefaultEqualityComparer<T>
    >(second, default);
#endregion

#region Zip
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in TEnumerable0 second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TResult0,
        TAction0
    >(this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TResult0, TAction0>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TEqualityComparer0, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey0, T0>,
        Grouping<TKey0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TKey0, T0, TResult0, TAction0>
    (in Grouping<TKey0, T0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TKey0 : unmanaged
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey0, T0>,
        Grouping<TKey0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        TResult0,
        TAction0
    >
    Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult0, TAction0>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
    second, TAction0 action, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
    where TResult0 : unmanaged
    where TAction0 : struct, IRefAction<T, T2, TResult0>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        TResult0,
        TAction0
    >
    Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult0, TAction0>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
    second, TAction0 action, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<T0, T1, T2>
    where TResult0 : unmanaged
    where TAction0 : struct, IRefAction<T, T2, TResult0>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TComparer0>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TComparer0 : struct, IRefFunc<T0, T0, int>
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
        second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<XYZXYZXYZ,Enumerator,T,PrependEnumerable<TEnumerable0,TEnumerator0,T0>,PrependEnumerable<TEnumerable0,TEnumerator0,T0>.Enumerator,T0,TResult0,TAction0>(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction1>,
        RangeRepeatEnumerable<T0, TAction1>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<T0, TResult0, TAction0, TAction1>
    (in RangeRepeatEnumerable<T0, TAction1>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TAction1 : struct, IRangeRepeat<T0>
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, RangeRepeatEnumerable<T0, TAction1>, RangeRepeatEnumerable<T0, TAction1>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
        second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrev0, TAction1>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TAction1 : struct, IRefAction<TPrev0, T0>
    where TPrev0 : unmanaged
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrev0, TAction1>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TAction1 : struct, ISelectIndex<TPrev0, T0>
    where TPrev0 : unmanaged
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction1>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction1>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction1>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrev0, TEnumerable1, TEnumerator1, TAction1>
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction1>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TAction1 : struct, IRefAction<TPrev0, TEnumerable1>
    where TPrev0 : unmanaged
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction1>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction1>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0, TResult0, TAction0>
    (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<T, T0, TResult0>
    where TResult0 : unmanaged
    where TPredicate0 : struct, IWhereIndex<T0>
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>.Enumerator,
        TResult1,
        TResult0,
        TAction0
    >
    Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TResult1, TAction0, TAction1>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>
    second, TAction0 action, T firstDefaultValue = default, TResult1 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where T1 : unmanaged
    where TAction1 : struct, IRefAction<T0, T1, TResult1>
    where TResult0 : unmanaged
    where TResult1 : unmanaged
    where TAction0 : struct, IRefAction<T, TResult1, TResult0>
    => new ZipEnumerable<XYZXYZXYZ, Enumerator, T, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>.Enumerator, TResult1, TResult0, TAction0>
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);
#endregion

#region Zip ValueTuple
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in TEnumerable0 second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey0, T0>,
        Grouping<TKey0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TKey0, T0>
    (in Grouping<TKey0, T0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TKey0 : unmanaged
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey0, T0>,
        Grouping<TKey0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)] public readonly ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        (T, T2),
        ZipValueTuple<T, T2>
    >
    Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
    second, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        (T, T2),
        ZipValueTuple<T, T2>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        (T, T2),
        ZipValueTuple<T, T2>
    >
    Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
    second, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<T0, T1, T2>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        (T, T2),
        ZipValueTuple<T, T2>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TComparer0>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TComparer0 : struct, IRefFunc<T0, T0, int>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
        second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >(this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<T0, TAction0>
    (in RangeRepeatEnumerable<T0, TAction0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TAction0 : struct, IRangeRepeat<T0>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
        second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPrev0, TAction0>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<TPrev0, T0>
    where TPrev0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPrev0, TAction0>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, ISelectIndex<TPrev0, T0>
    where TPrev0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPrev0, TEnumerable1, TEnumerator1, TAction0>
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<TPrev0, TEnumerable1>
    where TPrev0 : unmanaged
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0>
    (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0>
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly 
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TPredicate0 : struct, IWhereIndex<T0>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        (T, T0),
        ZipValueTuple<T, T0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
        TResult0,
        (T, TResult0),
        ZipValueTuple<T, TResult0>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
    second, T firstDefaultValue = default, TResult0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where T1 : unmanaged
    where TResult0 : unmanaged
    where TAction0 : struct, IRefAction<T0, T1, TResult0>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
        TResult0,
        (T, TResult0),
        ZipValueTuple<T, TResult0>
    >
    (this, second, default, firstDefaultValue, secondDefaultValue, allocator);
#endregion

#region Function
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool IsEmpty() => !Any();

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Any<TPredicate0>(TPredicate0 predicate)
    where TPredicate0 : struct, IRefFunc<T, bool>
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		if (!predicate.Calc(ref current)) continue;
		enumerator.Dispose();
		return true;
	}
    enumerator.Dispose();
    return false;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Any(Func<T, bool> predicate)
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		if (!predicate(current)) continue;
		enumerator.Dispose();
		return true;
	}
    enumerator.Dispose();
    return false;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool All<TPredicate0>(TPredicate0 predicate)
    where TPredicate0 :  struct, IRefFunc<T, bool>
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		if (predicate.Calc(ref current)) continue;
		enumerator.Dispose();
		return false;
	}
    enumerator.Dispose();
    return true;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool All(Func<T, bool> predicate)
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		if (predicate(current)) continue;
		enumerator.Dispose();
		return false;
	}
    enumerator.Dispose();
    return true;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly void Aggregate<TAccumulate0, TFunc0>(ref TAccumulate0 seed, TFunc0 func)
    where TFunc0 : struct, IRefAction<TAccumulate0, T>
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		func.Execute(ref seed, ref current);
	}
    enumerator.Dispose();
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly TNextResult0 Aggregate<TAccumulate0, TNextResult0, TFunc0, TResultFunc0>(ref TAccumulate0 seed, TFunc0 func, TResultFunc0 resultFunc)
    where TFunc0 : struct, IRefAction<TAccumulate0, T>
    where TResultFunc0 : struct, IRefFunc<TAccumulate0, TNextResult0>
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		func.Execute(ref seed, ref current);
	}
    enumerator.Dispose();
    return resultFunc.Calc(ref seed);
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly T Aggregate(Func<T, T, T> func)
{
    var enumerator = GetEnumerator();
	ref var current = ref enumerator.TryGetNext(out var success);
	if (!success)
    {
        enumerator.Dispose();
        throw new InvalidOperationException();
    }
    var seed = current;
	while (true)
	{
		current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		seed = func(seed, current);
	}
    enumerator.Dispose();
    return seed;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly TAccumulate0 Aggregate<TAccumulate0>(TAccumulate0 seed, Func<TAccumulate0, T, TAccumulate0> func)
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		seed = func(seed, current);
	}
    enumerator.Dispose();
    return seed;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly TNextResult0 Aggregate<TAccumulate0, TNextResult0>(TAccumulate0 seed, Func<TAccumulate0, T, TAccumulate0> func, Func<TAccumulate0, TNextResult0> resultFunc)
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		seed = func(seed, current);
	}
    enumerator.Dispose();
    return resultFunc(seed);
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Contains(in T value) => Contains(in value, EqualityComparer<T>.Default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Contains(T value) => Contains(in value, EqualityComparer<T>.Default);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Contains(in T value, IEqualityComparer<T> comparer)
{
    var enumerator = GetEnumerator();
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		if (!comparer.Equals(current, value)) continue;
		enumerator.Dispose();
		return true;
	}
    enumerator.Dispose();
    return false;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Contains(T value, IEqualityComparer<T> comparer) => Contains(in value, comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Contains<TComparer0>(in T value, ref TComparer0 comparer)
where TComparer0 : struct, IRefFunc<T, T, bool>
{
    var enumerator = GetEnumerator();
	ref var _value = ref Unsafe.AsRef(in value);
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		if (!comparer.Calc(ref current, ref _value)) continue;
		enumerator.Dispose();
		return true;
	}
    enumerator.Dispose();
    return false;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool Contains<TComparer0>(T value, TComparer0 comparer)
    where TComparer0 : struct, IRefFunc<T, T, bool>
    => Contains(in value, ref comparer);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly int Count(Func<T, bool> predicate)
    => (int)LongCount(predicate);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly int Count<TPredicate0>(TPredicate0 predicate)
    where TPredicate0 :  struct, IRefFunc<T, bool>
    => (int)LongCount(predicate);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly long LongCount(Func<T, bool> predicate)
{
    var enumerator = GetEnumerator();
    var count = 0L;
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		if (predicate(current))
			++count;
	}
    enumerator.Dispose();
    return count;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly long LongCount<TPredicate0>(in TPredicate0 predicate)
    where TPredicate0 :  struct, IRefFunc<T, bool>
{
    var enumerator = GetEnumerator();
    var count = 0L;
	bool success;
	while (true)
	{
		ref var current = ref enumerator.TryGetNext(out success);
		if (!success) break;
		if (predicate.Calc(ref current))
			++count;
	}
    enumerator.Dispose();
    return count;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool TryGetElementAt(long index, out T value)
{
    if (index < 0)
    {
        value = default;
        return false;
    }
    var enumerator = GetEnumerator();
	--index;
	bool success;
    for (var i = 0L; i < index; i++)
    {
		enumerator.TryGetNext(out success);
		if (success) continue;
        value = default;
        enumerator.Dispose();
        return false;
    }
    ref var current = ref enumerator.TryGetNext(out success);
	if (success)
		value = current;
	else
		value = default;
    enumerator.Dispose();
    return true;
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool TryGetFirst(out T first)
{
    var enumerator = GetEnumerator();
    if (enumerator.TryMoveNext(out first))
    {
        enumerator.Dispose();
        return true;
    }
    first = default;
    enumerator.Dispose();
    return false;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool TryGetLast(out T last)
{
    var enumerator = GetEnumerator();
    if (!enumerator.TryMoveNext(out last))
    {
        enumerator.Dispose();
        return false;
    }
	while (enumerator.TryMoveNext(out last))
        ;
    enumerator.Dispose();
    return true;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool TryGetSingle(out T value)
{
    value = default;
    var enumerator = GetEnumerator();
    var count = 0;
    while (enumerator.MoveNext())
    {
        value = enumerator.Current;
        if (++count <= 1) continue;
        enumerator.Dispose();
        return false;
    }
    enumerator.Dispose();
    return count == 1;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool TryGetSingle<TPredicate0>(out T value, TPredicate0 predicate)
    where TPredicate0 :  struct, IRefFunc<T, bool>
{
    value = default;
    var enumerator = GetEnumerator();
    var count = 0;
    while (enumerator.MoveNext())
    {
        if (!predicate.Calc(ref enumerator.Current)) continue;
        value = enumerator.Current;
        if (++count <= 1) continue;
        enumerator.Dispose();
        return false;
    }
    enumerator.Dispose();
    return count == 1;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly bool TryGetSingle(out T value, Func<T, bool> predicate)
{
    value = default;
    var enumerator = GetEnumerator();
    var count = 0;
    while (enumerator.MoveNext())
    {
        if (!predicate(enumerator.Current)) continue;
        value = enumerator.Current;
        if (++count <= 1) continue;
        enumerator.Dispose();
        return false;
    }
    enumerator.Dispose();
    return count == 1;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly Dictionary<TKey0, TElement0> ToDictionary<TKey0, TElement0>(Func<T, TKey0> keySelector, Func<T, TElement0> elementSelector)
{
    var answer = new Dictionary<TKey0, TElement0>();
    var enumerator = GetEnumerator();
    while (enumerator.MoveNext())
    {
        ref var current = ref enumerator.Current;
        answer.Add(keySelector(current), elementSelector(current));
    }
    enumerator.Dispose();
    return answer;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly Dictionary<TKey0, TElement0> ToDictionary<TKey0, TElement0, TKey0Func, TElement0Func>(TKey0Func keySelector, TElement0Func elementSelector)
    where TKey0Func : struct, IRefFunc<T, TKey0>
    where TElement0Func : struct, IRefFunc<T, TElement0>
{
    var answer = new Dictionary<TKey0, TElement0>();
    var enumerator = GetEnumerator();
    while (enumerator.MoveNext())
    {
        ref var current = ref enumerator.Current;
        answer.Add(keySelector.Calc(ref current), elementSelector.Calc(ref current));
    }
    enumerator.Dispose();
    return answer;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly HashSet<T> ToHashSet()
{
    var answer = new HashSet<T>();
    var enumerator = GetEnumerator();
    while (enumerator.MoveNext())
        answer.Add(enumerator.Current);
    enumerator.Dispose();
    return answer;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly HashSet<T> ToHashSet(IEqualityComparer<T> comparer)
{
    var answer = new HashSet<T>(comparer);
    var enumerator = GetEnumerator();
    while (enumerator.MoveNext())
        answer.Add(enumerator.Current);
    enumerator.Dispose();
    return answer;
}
            
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly List<T> ToList()
{
    var answer = new List<T>();
    var enumerator = GetEnumerator();
    while (enumerator.MoveNext())
        answer.Add(enumerator.Current);
    enumerator.Dispose();
    return answer;
}
#endregion

#region Sum
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	T
	Sum()
{
	var enumerator = GetEnumerator();
	if(!enumerator.MoveNext())
	{
		enumerator.Dispose();
		return default;
	}
	if(typeof(T) == typeof(byte))
	{
		var sum = Psuedo.As<T, byte>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, byte>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<byte, T>(ref sum);
	}
	else if(typeof(T) == typeof(sbyte))
	{
		var sum = Psuedo.As<T, sbyte>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, sbyte>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<sbyte, T>(ref sum);
	}
	else if(typeof(T) == typeof(short))
	{
		var sum = Psuedo.As<T, short>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, short>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<short, T>(ref sum);
	}
	else if(typeof(T) == typeof(ushort))
	{
		var sum = Psuedo.As<T, ushort>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, ushort>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<ushort, T>(ref sum);
	}
	else if(typeof(T) == typeof(int))
	{
		var sum = Psuedo.As<T, int>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, int>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<int, T>(ref sum);
	}
	else if(typeof(T) == typeof(uint))
	{
		var sum = Psuedo.As<T, uint>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, uint>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<uint, T>(ref sum);
	}
	else if(typeof(T) == typeof(long))
	{
		var sum = Psuedo.As<T, long>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, long>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<long, T>(ref sum);
	}
	else if(typeof(T) == typeof(ulong))
	{
		var sum = Psuedo.As<T, ulong>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, ulong>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<ulong, T>(ref sum);
	}
	else if(typeof(T) == typeof(float))
	{
		var sum = Psuedo.As<T, float>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, float>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<float, T>(ref sum);
	}
	else if(typeof(T) == typeof(double))
	{
		var sum = Psuedo.As<T, double>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, double>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<double, T>(ref sum);
	}
	else if(typeof(T) == typeof(decimal))
	{
		var sum = Psuedo.As<T, decimal>(ref enumerator.Current);
		while (enumerator.MoveNext())
			sum += Psuedo.As<T, decimal>(ref enumerator.Current);
		enumerator.Dispose();
		return Psuedo.As<decimal, T>(ref sum);
	}
	return default;
}
#endregion

#region Average
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	bool
	TryGetAverage(out T value)
{
	var enumerator = GetEnumerator();
	if(!enumerator.MoveNext())
	{
		value = default;
		enumerator.Dispose();
		return false;
	}
	var count = 1L;
	if(typeof(T) == typeof(byte))
	{
		long sum = Psuedo.As<T, byte>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, byte>(ref enumerator.Current);
		}
		var val = (byte)(sum / count);
		value = Psuedo.As<byte, T>(ref val);
	}
	else if(typeof(T) == typeof(sbyte))
	{
		long sum = Psuedo.As<T, sbyte>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, sbyte>(ref enumerator.Current);
		}
		var val = (sbyte)(sum / count);
		value = Psuedo.As<sbyte, T>(ref val);
	}
	else if(typeof(T) == typeof(short))
	{
		long sum = Psuedo.As<T, short>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, short>(ref enumerator.Current);
		}
		var val = (short)(sum / count);
		value = Psuedo.As<short, T>(ref val);
	}
	else if(typeof(T) == typeof(ushort))
	{
		long sum = Psuedo.As<T, ushort>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, ushort>(ref enumerator.Current);
		}
		var val = (ushort)(sum / count);
		value = Psuedo.As<ushort, T>(ref val);
	}
	else if(typeof(T) == typeof(int))
	{
		long sum = Psuedo.As<T, int>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, int>(ref enumerator.Current);
		}
		var val = (int)(sum / count);
		value = Psuedo.As<int, T>(ref val);
	}
	else if(typeof(T) == typeof(uint))
	{
		long sum = Psuedo.As<T, uint>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, uint>(ref enumerator.Current);
		}
		var val = (uint)(sum / count);
		value = Psuedo.As<uint, T>(ref val);
	}
	else if(typeof(T) == typeof(long))
	{
		var sum = Psuedo.As<T, long>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, long>(ref enumerator.Current);
		}
		sum /= count;
		value = Psuedo.As<long, T>(ref sum);
	}
	else if(typeof(T) == typeof(ulong))
	{
		var sum = Psuedo.As<T, ulong>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, ulong>(ref enumerator.Current);
		}
		sum /= (ulong)count;
		value = Psuedo.As<ulong, T>(ref sum);
	}
	else if(typeof(T) == typeof(float))
	{
		var sum = Psuedo.As<T, float>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, float>(ref enumerator.Current);
		}
		sum /= count;
		value = Psuedo.As<float, T>(ref sum);
	}
	else if(typeof(T) == typeof(double))
	{
		var sum = Psuedo.As<T, double>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, double>(ref enumerator.Current);
		}
		sum /= count;
		value = Psuedo.As<double, T>(ref sum);
	}
	else if(typeof(T) == typeof(decimal))
	{
		var sum = Psuedo.As<T, decimal>(ref enumerator.Current);
		while (enumerator.MoveNext())
		{
			++count;
			sum += Psuedo.As<T, decimal>(ref enumerator.Current);
		}
		sum /= count;
		value = Psuedo.As<decimal, T>(ref sum);
	}
	else
	{
		value = enumerator.Current;
	}
	enumerator.Dispose();
	return true;
}
#endregion

#region OrderByDefault
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultOrderByAscending<T>
    >
    OrderBy(Allocator allocator = Allocator.Temp)
    => new OrderByEnumerable<XYZXYZXYZ, Enumerator, T, DefaultOrderByAscending<T>>(this, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    OrderByEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultOrderByDescending<T>
    >
    OrderByDescending(Allocator allocator = Allocator.Temp)
    => new OrderByEnumerable<XYZXYZXYZ, Enumerator, T, DefaultOrderByDescending<T>>(this, default, allocator);
#endregion

#region Union Default
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator, TEnumerable0, TEnumerator0, T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator, TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
	>
    Union<TEnumerable0, TEnumerator0>
    (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator, TEnumerable0, TEnumerator0, T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator, TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
	>
    (Concat<TEnumerable0, TEnumerator0>(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T>
            second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
			ConcatEnumerable<
				XYZXYZXYZ,
				Enumerator,
				AppendEnumerable<TEnumerable0, TEnumerator0, T>,
				AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
				T>,
			ConcatEnumerable<
				XYZXYZXYZ,
				Enumerator,
				AppendEnumerable<TEnumerable0, TEnumerator0, T>,
				AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
				T>.Enumerator,
			T,
			DefaultEqualityComparer<T>,
			DefaultGetHashCodeFunc<T>
		>
		(Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
	>
    Union
    (in NativeEnumerable<T>
        second, Allocator allocator = Allocator.Temp)
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union
    (NativeArray<T>
        second, Allocator allocator = Allocator.Temp)
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(NativeEnumerable.AsRefEnumerable(second)), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
	>
    Union
    (in ArrayEnumerable<T>
        second, Allocator allocator = Allocator.Temp)
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
	>
    Union
    (T[]
        second, Allocator allocator = Allocator.Temp)
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(NativeEnumerable.AsRefEnumerable(second)), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
	>
    Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0, TEqualityComparer1, TGetHashCodeFunc1>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer1 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc1 : struct, IRefFunc<T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    Union<TEnumerable0, TEnumerator0, TKey0>
    (in Grouping<TKey0, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TKey0 : unmanaged
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    (Concat(in second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<XYZXYZXYZ, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
        ConcatEnumerable<XYZXYZXYZ, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
        second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where T0Selector : struct,
    IRefFunc<T0,
        WhereIndexEnumerable<
            NativeEnumerable<T1>,
            NativeEnumerable<T1>.Enumerator,
            T1,
            GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
            >,
        T>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new DistinctEnumerable<
        ConcatEnumerable<XYZXYZXYZ, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
        ConcatEnumerable<XYZXYZXYZ, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<XYZXYZXYZ, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
        ConcatEnumerable<XYZXYZXYZ, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
        second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new DistinctEnumerable<
        ConcatEnumerable<XYZXYZXYZ, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
        ConcatEnumerable<XYZXYZXYZ, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0, TComparer0>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer0 : struct, IRefFunc<T, T, int>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TAction0>
    (in RangeRepeatEnumerable<T, TAction0>
        second, Allocator allocator = Allocator.Temp)
    where TAction0 : struct, IRangeRepeat<T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TPrevEnumerable0, TPrevEnumerator0, TPrev0, TAction0>
    (in SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>
        second, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TPrevEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrev0>
    where TAction0 : struct, IRefAction<TPrev0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TPrevEnumerable0, TPrevEnumerator0, TPrev0, TAction0>
    (in SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>
        second, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TPrevEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrev0>
    where TAction0 : struct, ISelectIndex<TPrev0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>,
            SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, TAction0>
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>
        second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TAction0 : struct, IRefAction<T0, TEnumerable1>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
            SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
	DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
	>
    Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
    (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
            SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
	>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    Union<TEnumerable0, TEnumerator0>
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipEnumerable<TEnumerable0, TEnumerator0, T>,
            TEnumerator0,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    Union<TEnumerable0, TEnumerator0>
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    Union<TEnumerable0, TEnumerator0, TPredicate0>
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TEnumerator0,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    Union<TEnumerable0, TEnumerator0, TPredicate0>
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    Union<TEnumerable0, TEnumerator0>
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
            SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    Union<TEnumerable0, TEnumerator0>
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
            TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>
    >
    Union<TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
        second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IWhereIndex<T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>
        second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => new DistinctEnumerable<
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T>,
        ConcatEnumerable<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T>.Enumerator,
        T,
        DefaultEqualityComparer<T>,
        DefaultGetHashCodeFunc<T>>
    (Concat(second), default, default, allocator);
#endregion

#region Intersect Default
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TEnumerable0,
        TEnumerator0,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            TEnumerable0,
            TEnumerator0,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0>
    (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TEnumerable0,
        TEnumerator0,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            TEnumerable0,
            TEnumerator0,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect
    (in NativeEnumerable<T> second, Allocator allocator = Allocator.Temp)
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
   (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect
    (NativeArray<T> second, Allocator allocator = Allocator.Temp)
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect
    (in ArrayEnumerable<T> second, Allocator allocator = Allocator.Temp)
	=> new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
	(this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect
    (T[] second, Allocator allocator = Allocator.Temp)
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
   (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TKey0>
    (in Grouping<TKey0, T> second, Allocator allocator = Allocator.Temp)
    where TKey0 : unmanaged
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
    second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct,
    IRefFunc<T0,
        WhereIndexEnumerable<
            NativeEnumerable<T1>,
            NativeEnumerable<T1>.Enumerator,
            T1,
            GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
            >,
        T>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >(this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
    second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >(this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, TComparer1>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer1 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        RangeRepeatEnumerable<T, TAction0>,
        RangeRepeatEnumerable<T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TAction0>
    (in RangeRepeatEnumerable<T, TAction0> second, Allocator allocator = Allocator.Temp)
    where TAction0 : struct, IRangeRepeat<T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        RangeRepeatEnumerable<T, TAction0>,
        RangeRepeatEnumerable<T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TAction0 : struct, IRefAction<T0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TAction0 : struct, ISelectIndex<T0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IWhereIndex<T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
	(this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        T,
        IntersectOperation<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);
#endregion

#region Except Default
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TEnumerable0,
        TEnumerator0,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TEnumerable0,
            TEnumerator0,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0>
    (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        TEnumerable0,
        TEnumerator0,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            TEnumerable0,
            TEnumerator0,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>,
            AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except
    (in NativeEnumerable<T> second, Allocator allocator = Allocator.Temp)
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
   (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except
    (NativeArray<T> second, Allocator allocator = Allocator.Temp)
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        NativeEnumerable<T>,
        NativeEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            NativeEnumerable<T>,
            NativeEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except
    (in ArrayEnumerable<T> second, Allocator allocator = Allocator.Temp)
	=> new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
	(this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except
    (T[] second, Allocator allocator = Allocator.Temp)
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ArrayEnumerable<T>,
        ArrayEnumerable<T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ArrayEnumerable<T>,
            ArrayEnumerable<T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
   (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEnumerator1 : struct, IRefEnumerator<T>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
            ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
            DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
            DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TKey0>
    (in Grouping<TKey0, T> second, Allocator allocator = Allocator.Temp)
    where TKey0 : unmanaged
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        Grouping<TKey0, T>,
        Grouping<TKey0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            Grouping<TKey0, T>,
            Grouping<TKey0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
    second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct,
    IRefFunc<T0,
        WhereIndexEnumerable<
            NativeEnumerable<T1>,
            NativeEnumerable<T1>.Enumerator,
            T1,
            GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
            >,
        T>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >(this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
    second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where T0Selector : struct, IRefFunc<T0, T1, T>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
            JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >(this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, TComparer1>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TComparer1 : struct, IRefFunc<T, T, int>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
            OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>,
            PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        RangeRepeatEnumerable<T, TAction0>,
        RangeRepeatEnumerable<T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TAction0>
    (in RangeRepeatEnumerable<T, TAction0> second, Allocator allocator = Allocator.Temp)
    where TAction0 : struct, IRangeRepeat<T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        RangeRepeatEnumerable<T, TAction0>,
        RangeRepeatEnumerable<T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            RangeRepeatEnumerable<T, TAction0>,
            RangeRepeatEnumerable<T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
            ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TAction0 : struct, IRefAction<T0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, T0, TAction0>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TAction0 : struct, ISelectIndex<T0, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
            SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IRefFunc<T, bool>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, TPredicate0>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, Allocator allocator = Allocator.Temp)
    where TEnumerator0 : struct, IRefEnumerator<T>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
    where TPredicate0 : struct, IWhereIndex<T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
            WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
	(this, second, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where T1 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TAction0 : struct, IRefAction<T0, T1, T>
    => new SetOperationEnumerable<
        XYZXYZXYZ,
        Enumerator,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
        T,
        ExceptOperation<
            XYZXYZXYZ,
            Enumerator,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
            ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
            T,
            DefaultOrderByAscending<T>
        >
    >
    (this, second, default, allocator);
#endregion

#region Join
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
	=> new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
	(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
	=> new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TEnumerable1, TEnumerator1
    >
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
	where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TEqualityComparer1, TGetHashCodeFunc0
    >
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
	where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey1, T0>,
        Grouping<TKey1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TKey1
    >
    (in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
	where TKey1 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey1, T0>,
        Grouping<TKey1, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TEnumerable1, TEnumerator1, TSetOperation0
    >
    (in SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        > inner,
    in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>.Enumerator,
        T0,
        TKey0,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1, TKey0,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector>
    (
        in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>
        inner,
        in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
        in T1Selector resultSelector, Allocator allocator = Allocator.Temp
    )
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where T0 : unmanaged
    where TKey2 : unmanaged
    where TKey0 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
    where TEqualityComparer1 : struct, IRefFunc<TKey2, TKey2, bool>
    where T0Selector : struct,
    IRefFunc<TOuterSource0,
        WhereIndexEnumerable<
            NativeEnumerable<TInnerSource0>,
            NativeEnumerable<TInnerSource0>.Enumerator,
            TInnerSource0,
            GroupJoinPredicate<TInnerSource0, TKey2, TEqualityComparer1>
            >,
        T0>
    where T1 : unmanaged
    where TOuterKeySelector1 : struct, IRefFunc<T, TKey0>
    where TInnerKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T1Selector : struct, IRefFunc<T, T0, T1>
    =>
    new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>.Enumerator,
        T0,
        TKey0,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        DefaultEqualityComparer<TKey0>
    >(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey0,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey0,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector>
    (
        in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
        inner,
        in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
        in T1Selector resultSelector, Allocator allocator = Allocator.Temp
    )
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where T0 : unmanaged
    where TKey2 : unmanaged
    where TKey0 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey2, TKey2, bool>
    where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
    where T1 : unmanaged
    where TOuterKeySelector1 : struct, IRefFunc<T, TKey0>
    where TInnerKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T1Selector : struct, IRefFunc<T, T0, T1>
    =>
    new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey0,
        TOuterKeySelector1,
        TInnerKeySelector1,
        T1,
        T1Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TComparer0
    >
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TComparer0 : struct, IRefFunc<T0, T0, int>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TAction0
    >
    (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TAction0 : struct, IRangeRepeat<T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
	(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TPrev0, TAction0
    >
    (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TAction0 : struct, IRefAction<TPrev0, T0>
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
	=> new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TPrev0, TAction0
    >
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TAction0 : struct, ISelectIndex<TPrev0, T0>
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
	(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TEnumerable1, TEnumerator1, TPrev0, TAction0
    >
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TAction0 : struct, IRefAction<TPrev0, TEnumerable1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
	(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TPredicate0
    >
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TPredicate0
    >
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
    >
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TPredicate0
    >
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
	(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TPredicate0
    >
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
	where TPredicate0 : struct, IWhereIndex<T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
	(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
        , TEnumerable1, TEnumerator1, T2, T3, TAction0
    >
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where T3 : unmanaged
    where TAction0 : struct, IRefAction<T2, T3, T0>
    where TEnumerator0 : struct, IRefEnumerator<T2>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T, TKey0>
    where TKeySelector1 : struct, IRefFunc<T0, TKey0>
    where T0Selector : struct, IRefFunc<T, T0, T1>
	where TEnumerator1 : struct, IRefEnumerator<T3>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        TKeySelector0,
        TKeySelector1,
        T1,
        T0Selector,
        DefaultEqualityComparer<TKey0>
    >
	(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);
#endregion

#region Join Default Func
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in TEnumerable0 inner, in Func<T, TKey0> outerKeySelector, in Func<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in NativeEnumerable<T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (NativeArray<T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
	=> new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in ArrayEnumerable<T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (T0[] inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TEnumerable1, TEnumerator1
    >
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TEqualityComparer1, TGetHashCodeFunc0
    >
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey1, T0>,
        Grouping<TKey1, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TKey1
    >
    (in Grouping<TKey1, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKey1 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey1, T0>,
        Grouping<TKey1, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TEnumerable1, TEnumerator1, TSetOperation0
    >
    (in SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        > inner,
    in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >,
        SetOperationEnumerable<
            TEnumerable0,
            TEnumerator0,
            TEnumerable1,
            TEnumerator1,
            T0,
            TSetOperation0
        >.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
        TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1, TKey0,
        T1
    >
    (
        in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>
        inner,
        in Func<T, TKey0> outerKeySelector,
		in Func<T0, TKey0> innerKeySelector,
        in Func<T, T0, T1> resultSelector,
		Allocator allocator = Allocator.Temp
    )
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where T0 : unmanaged
    where TKey2 : unmanaged
    where TKey0 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
    where TEqualityComparer1 : struct, IRefFunc<TKey2, TKey2, bool>
    where T2Selector : struct,
    IRefFunc<TOuterSource0,
        WhereIndexEnumerable<
            NativeEnumerable<TInnerSource0>,
            NativeEnumerable<TInnerSource0>.Enumerator,
            TInnerSource0,
            GroupJoinPredicate<TInnerSource0, TKey2, TEqualityComparer1>
            >,
        T0>
    where T1 : unmanaged
    =>
    new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
		TOuterEnumerable0, 
		TOuterEnumerator0,
		TOuterSource0,
		TInnerEnumerable0, 
		TInnerEnumerator0, 
		TInnerSource0,
        TKey2, 
		TOuterKeySelector0, 
		TInnerKeySelector0,
		T0,
		T2Selector, 
		TKeyEqualityComparer0,
		TKey0,
		T1
    >
    (
        in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>
        inner,
        in Func<T, TKey0> outerKeySelector,
		in Func<T0, TKey0> innerKeySelector,
        in Func<T, T0, T1> resultSelector, 
		Allocator allocator = Allocator.Temp
    )
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where T0 : unmanaged
    where TKey2 : unmanaged
    where TKey0 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey2, TKey2, bool>
    where T2Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
    where T1 : unmanaged
	=>
    new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
            TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TComparer0
    >
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TComparer0 : struct, IRefFunc<T0, T0, int>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        T0, TKey0, T1
        , TAction0
    >
    (in RangeRepeatEnumerable<T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TKey0 : unmanaged
    where TAction0 : struct, IRangeRepeat<T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TPrev0, TAction0
    >
    (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TAction0 : struct, IRefAction<TPrev0, T0>
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TPrev0, TAction0
    >
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where TAction0 : struct, ISelectIndex<TPrev0, T0>
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TKey0 : unmanaged
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TEnumerable1, TEnumerator1, TPrev0, TAction0
    >
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where TPrev0 : unmanaged
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TAction0 : struct, IRefAction<TPrev0, TEnumerable1>
    where TKey0 : unmanaged
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged



    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged



    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TPredicate0
    >
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged



    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TPredicate0
    >
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged



    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged



    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
    >
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged



    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TPredicate0
    >
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TPredicate0
    >
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TPredicate0 : struct, IWhereIndex<T0>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    Join<
        TEnumerable0, TEnumerator0, T0, TKey0, T1
        , TEnumerable1, TEnumerator1, T2, T3, TAction0
    >
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where T3 : unmanaged
    where TAction0 : struct, IRefAction<T2, T3, T0>
    where TEnumerator0 : struct, IRefEnumerator<T2>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
    where TKey0 : unmanaged



    where TEnumerator1 : struct, IRefEnumerator<T3>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
    => new JoinEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
        T0,
        TKey0,
        DelegateFuncToStructOperatorFunc<T, TKey0>,
        DelegateFuncToStructOperatorFunc<T0, TKey0>,
        T1,
        DelegateFuncToStructOperatorFunc<T, T0, T1>,
        DefaultEqualityComparer<TKey0>
    >
    (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);
#endregion

#region Zip Function
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in TEnumerable0 second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TEnumerable0,
        TEnumerator0,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TResult1>
    (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0, TResult1>
    (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey0, T0>,
        Grouping<TKey0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TKey0, T0, TResult1>
    (in Grouping<TKey0, T0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TKey0 : unmanaged
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey0, T0>,
        Grouping<TKey0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        TResult1,
        DelegateFuncToAction<T, T2, TResult1>
    >
    Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult1>
    (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
    second, Func<T, T2, TResult1> action, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        TResult1,
        DelegateFuncToAction<T, T2, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        TResult1,
        DelegateFuncToAction<T, T2, TResult1>
    >
    Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult1>
    (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
    second, Func<T, T2, TResult1> action, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where T1 : unmanaged
    where T2 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeySelector1 : struct, IRefFunc<T1, TKey0>
    where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<T0, T1, T2>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
        JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
        T2,
        TResult1,
        DelegateFuncToAction<T, T2, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TComparer0, TResult1>
    (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TComparer0 : struct, IRefFunc<T0, T0, int>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
        second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<T0, TAction0, TResult1>
    (in RangeRepeatEnumerable<T0, TAction0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TAction0 : struct, IRangeRepeat<T0>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
        second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPrev0, TAction0, TResult1>
    (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<TPrev0, T0>
    where TPrev0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPrev0, TAction0, TResult1>
    (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, ISelectIndex<TPrev0, T0>
    where TPrev0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPrev0, TEnumerable1, TEnumerator1, TAction0, TResult1>
    (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where T0 : unmanaged
    where TAction0 : struct, IRefAction<TPrev0, TEnumerable1>
    where TPrev0 : unmanaged
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0, TResult1>
    (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where T0 : unmanaged
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
        SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
    (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
    (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TResult1>
    (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
    (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
    (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
    second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TPredicate0 : struct, IWhereIndex<T0>
    where TResult1 : unmanaged
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        T0,
        TResult1,
        DelegateFuncToAction<T, T0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
        TResult0,
        TResult1,
        DelegateFuncToAction<T, TResult0, TResult1>
    >
    Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0, TResult1>
    (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
    second, Func<T, TResult0, TResult1> action, T firstDefaultValue = default, TResult0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where T0 : unmanaged
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
    where TEnumerator1 : struct, IRefEnumerator<T1>
    where T1 : unmanaged
    where TResult0 : unmanaged
    where TResult1 : unmanaged
    where TAction0 : struct, IRefAction<T0, T1, TResult0>
    => new ZipEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
        ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
        TResult0,
        TResult1,
        DelegateFuncToAction<T, TResult0, TResult1>
    >
    (this, second, action, firstDefaultValue, secondDefaultValue, allocator);
#endregion

#region SelectMany
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        DelegateFuncToAction<T, NativeEnumerable<T0>>
    >
    SelectMany<T0>(Func<T, NativeEnumerable<T0>> func)
    where T0 : unmanaged
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        DelegateFuncToAction<T, NativeEnumerable<T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        NativeArrayToNativeEnumerableActionWrapper<T, T0>
    >
    SelectMany<T0>(Func<T, NativeArray<T0>> func)
    where T0 : unmanaged
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        NativeEnumerable<T0>,
        NativeEnumerable<T0>.Enumerator,
        NativeArrayToNativeEnumerableActionWrapper<T, T0>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        DelegateFuncToAction<T, ArrayEnumerable<T0>>
    >
    SelectMany<T0>(Func<T, ArrayEnumerable<T0>> func)
    where T0 : unmanaged
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        DelegateFuncToAction<T, ArrayEnumerable<T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        ArrayToArrayEnumerableActionWrapper<T, T0>
    >
    SelectMany<T0>(Func<T, T0[]> func)
    where T0 : unmanaged
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ArrayEnumerable<T0>,
        ArrayEnumerable<T0>.Enumerator,
        ArrayToArrayEnumerableActionWrapper<T, T0>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
        AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        DelegateFuncToAction<T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>(Func<T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEnumerator1 : struct, IRefEnumerator<T0>
    where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
        ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
        DelegateFuncToAction<T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
        DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        DelegateFuncToAction<T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>(Func<T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
    where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
        DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
        DelegateFuncToAction<T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey0, TElement0>,
        GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>,
        GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>.Enumerator,
        DelegateFuncToAction<T, GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>(Func<T, GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TElement0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TElementSelector0 : struct, IRefFunc<T0, TElement0>
    where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        Grouping<TKey0, TElement0>,
        GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>,
        GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>.Enumerator,
        DelegateFuncToAction<T, GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        Grouping<TKey0, T0>,
        Grouping<TKey0, T0>.Enumerator,
        DelegateFuncToAction<T, Grouping<TKey0, T0>>
    >
    SelectMany<T0, TKey0>(Func<T, Grouping<TKey0, T0>> func)
    where T0 : unmanaged
    where TKey0 : unmanaged
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        Grouping<TKey0, T0>,
        Grouping<TKey0, T0>.Enumerator,
        DelegateFuncToAction<T, Grouping<TKey0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        DelegateFuncToAction<T, GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>>
    >
    SelectMany<T0, TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0Selector, TKeyEqualityComparer0>(Func<T, GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>> func)
    where T0 : unmanaged
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where TKey0 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
    where T0Selector : struct,
    IRefFunc<TOuterSource0,
        WhereIndexEnumerable<
            NativeEnumerable<TInnerSource0>,
            NativeEnumerable<TInnerSource0>.Enumerator,
            TInnerSource0,
            GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
            >,
        T0>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        DelegateFuncToAction<T, GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        DelegateFuncToAction<T, JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>>
    >
    SelectMany<T0, TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0Selector, TKeyEqualityComparer0>(
        Func<T,
            JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
        > func)
    where T0 : unmanaged
    where TOuterSource0 : unmanaged
    where TInnerSource0 : unmanaged
    where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
    where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
    where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
    where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
    where TKey0 : unmanaged
    where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
    where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
        JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
        DelegateFuncToAction<T, JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>,
        MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>.Enumerator,
        DelegateFuncToAction<T, MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>(Func<T, MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TKey0 : unmanaged
    where TKeySelector0 : struct, IRefFunc<T0, TKey0>
    where TKeyRenewPredicate0 : struct, IRefFunc<TKey0, TKey0, bool>
    where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>,
        MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>.Enumerator,
        DelegateFuncToAction<T, MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        DelegateFuncToAction<T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0, TComparer0>(Func<T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TComparer0 : struct, IRefFunc<T0, T0, int>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
        OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
        DelegateFuncToAction<T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
        PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        DelegateFuncToAction<T, RangeRepeatEnumerable<T0, TAction0>>
    >
    SelectMany<T0, TAction0>(Func<T, RangeRepeatEnumerable<T0, TAction0>> func)
    where T0 : unmanaged
    where TAction0 : struct, IRangeRepeat<T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        RangeRepeatEnumerable<T0, TAction0>,
        RangeRepeatEnumerable<T0, TAction0>.Enumerator,
        DelegateFuncToAction<T, RangeRepeatEnumerable<T0, TAction0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
        ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        DelegateFuncToAction<T, SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>>
    >
    SelectMany<T0, TPrevEnumerable0, TPrevEnumerator0, TPrev0, TAction0>(Func<T, SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>> func)
    where T0 : unmanaged
    where TPrev0 : unmanaged
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrev0>
    where TPrevEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TAction0 : struct, IRefAction<TPrev0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>,
        SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        DelegateFuncToAction<T, SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        DelegateFuncToAction<T, SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>>
    >
    SelectMany<T0, TPrevEnumerable0, TPrevEnumerator0, TPrev0, TAction0>(Func<T, SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>> func)
    where T0 : unmanaged
    where TPrev0 : unmanaged
    where TAction0 : struct, ISelectIndex<TPrev0, T0>
    where TPrevEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrev0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>,
        SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>.Enumerator,
        DelegateFuncToAction<T, SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrev0, T0, TAction0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, T0Enumerable, T0Enumerator, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, T0Enumerable, T0Enumerator, TAction0>.Enumerator,
        DelegateFuncToAction<T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, T0Enumerable, T0Enumerator, TAction0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0, TPrev0, T0Enumerable, T0Enumerator, TAction0>(Func<T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, T0Enumerable, T0Enumerator, TAction0>> func)
    where T0 : unmanaged
    where TPrev0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<TPrev0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrev0>
    where T0Enumerator : struct, IRefEnumerator<T0>
    where T0Enumerable : struct, IRefEnumerable<T0Enumerator, T0>
    where TAction0 : struct, IRefAction<TPrev0, T0Enumerable>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, T0Enumerable, T0Enumerator, TAction0>,
        SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, T0Enumerable, T0Enumerator, TAction0>.Enumerator,
        DelegateFuncToAction<T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrev0, T0, T0Enumerable, T0Enumerator, TAction0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        DelegateFuncToAction<T, SkipEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, SkipEnumerable<TEnumerable0, TEnumerator0, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
        TEnumerator0,
        DelegateFuncToAction<T, SkipEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        DelegateFuncToAction<T, SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0, TPredicate0>(Func<T, SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TEnumerator0,
        DelegateFuncToAction<T, SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, TakeEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, TakeEnumerable<TEnumerable0, TEnumerator0, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, TakeEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
        TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
        DelegateFuncToAction<T, TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        DelegateFuncToAction<T, TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>>
    >
    SelectMany<T0, TEnumerable0, TEnumerator0, TPredicate0>(Func<T, TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>> func)
    where T0 : unmanaged
    where TEnumerator0 : struct, IRefEnumerator<T0>
    where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
    where TPredicate0 : struct, IRefFunc<T0, bool>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
        TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
        DelegateFuncToAction<T, TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>.Enumerator,
        DelegateFuncToAction<T, WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>>
    >
    SelectMany<T0, TPrevEnumerable0, TPrevEnumerator0, TPredicate0>(Func<T, WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>> func)
    where T0 : unmanaged
    where TPredicate0 : struct, IRefFunc<T0, bool>
    where TPrevEnumerator0 : struct, IRefEnumerator<T0>
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>,
        WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>.Enumerator,
        DelegateFuncToAction<T, WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>.Enumerator,
        DelegateFuncToAction<T, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>>
    >
    SelectMany<T0, TPrevEnumerable0, TPrevEnumerator0, TPredicate0>(Func<T, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>> func)
    where T0 : unmanaged
    where TPredicate0 : struct, IWhereIndex<T0>
    where TPrevEnumerator0 : struct, IRefEnumerator<T0>
    where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>,
        WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>.Enumerator,
        DelegateFuncToAction<T, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirsT0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>,
        ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirsT0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>.Enumerator,
        DelegateFuncToAction<T, ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirsT0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>>
    >
    SelectMany<T0, TFirstEnumerable0, TFirstEnumerator0, TFirsT0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, TAction0>(Func<T, ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirsT0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>> func)
    where T0 : unmanaged
    where TFirsT0 : unmanaged
    where TSecondSource0 : unmanaged
    where TFirstEnumerator0 : struct, IRefEnumerator<TFirsT0>
    where TFirstEnumerable0 : struct, IRefEnumerable<TFirstEnumerator0, TFirsT0>
    where TSecondEnumerator0 : struct, IRefEnumerator<TSecondSource0>
    where TSecondEnumerable0 : struct, IRefEnumerable<TSecondEnumerator0, TSecondSource0>
    where TAction0 : struct, IRefAction<TFirsT0, TSecondSource0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirsT0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>,
        ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirsT0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>.Enumerator,
        DelegateFuncToAction<T, ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirsT0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>>
    >
    (this, func);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
public readonly
    SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>,
        SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>.Enumerator,
        DelegateFuncToAction<T, SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>>
    >
    SelectMany<T0, TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, TSetOperation0>(Func<T, SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>> func)
    where T0 : unmanaged
    where TFirstEnumerable0 : struct, IRefEnumerable<TFirstEnumerator0, T0>
    where TFirstEnumerator0 : struct, IRefEnumerator<T0>
    where TSecondEnumerable0 : struct, IRefEnumerable<TSecondEnumerator0, T0>
    where TSecondEnumerator0 : struct, IRefEnumerator<T0>
    where TSetOperation0 : struct, ISetOperation<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0>
    => new SelectManyEnumerable<
        XYZXYZXYZ,
        Enumerator,
        T,
        T0,
        SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>,
        SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>.Enumerator,
        DelegateFuncToAction<T, SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>>
    >
    (this, func);
#endregion