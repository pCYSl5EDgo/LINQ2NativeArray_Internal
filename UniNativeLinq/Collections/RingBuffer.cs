using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace UniNativeLinq
{
    public unsafe struct
        RingBuffer<T>
        : IRefEnumerable<RingBuffer<T>.Enumerator, T>, IDisposable
        where T : unmanaged
    {
        public T* Elements;
        public long Capacity;
        public long Length;
        public long StartIndex;
        public Allocator Allocator;

        public RingBuffer(long capacity, Allocator allocator)
        {
            Elements = UnsafeUtilityEx.Malloc<T>(capacity, allocator);
            Capacity = capacity;
            Length = 0;
            StartIndex = 0;
            Allocator = allocator;
        }

        public ref T this[long index]
        {
            get
            {
                index += StartIndex;
                if (index >= Capacity)
                    index -= Capacity;
                return ref Elements[index];
            }
        }

        public bool IsFull => Length == Capacity;
        public bool IsEmpty => Length == 0L;

        public void Add(in T value)
        {
            if (Capacity <= Length)
                ReAllocate();
            var index = StartIndex + Length;
            if (index >= Capacity)
                index -= Capacity;
            Elements[index] = value;
            ++Length;
        }

        public readonly Enumerator GetEnumerator() => new Enumerator(this);
        readonly IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
        readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        public struct Enumerator
            : IRefEnumerator<T>
        {
            internal RingBuffer<T> Parent;

            internal Enumerator(in RingBuffer<T> parent) => Parent = parent;

            public ref T Current => ref Parent.Elements[Parent.StartIndex];
            T IEnumerator<T>.Current => Current;
            object IEnumerator.Current => Current;

            public void Dispose() => this = default;

            public bool MoveNext()
            {
                ++Parent.StartIndex;
                if (Parent.StartIndex >= Parent.Capacity)
                    Parent.StartIndex = 0;
                return --Parent.Length >= 0;
            }

            public void Reset() => throw new InvalidOperationException();

            public ref T TryGetNext(out bool success)
            {
                ++Parent.StartIndex;
                success = --Parent.Length >= 0;
                if (Parent.StartIndex >= Parent.Capacity)
                    Parent.StartIndex = 0;
                return ref Parent.Elements[Parent.StartIndex];
            }
        }

        public readonly bool Any() => Length != 0;

        public readonly bool CanFastCount() => true;

        public readonly int Count() => (int)Length;

        public readonly long LongCount() => Length;

        public void RemoveFirst()
        {
            --Length;
            ++StartIndex;
            if (StartIndex >= Capacity)
                StartIndex = 0;
        }

        public void RemoveLast() => --Length;

        public readonly void CopyTo(T* dest)
        {
            if (StartIndex + Length <= Capacity)
            {
                UnsafeUtilityEx.MemCpy(dest, Elements + StartIndex, Length);
            }
            else
            {
                var count = Capacity - StartIndex;
                UnsafeUtilityEx.MemCpy(dest, Elements + StartIndex, count);
                UnsafeUtilityEx.MemCpy(dest + count, Elements, Length - count);
            }
        }

        public readonly T[] ToArray()
        {
            var answer = new T[Length];
            CopyTo((T*)Unsafe.AsPointer(ref answer[0]));
            return answer;
        }

        public readonly NativeArray<T> ToNativeArray(Allocator allocator)
        {
            var answer = new NativeArray<T>((int)Length, allocator, NativeArrayOptions.UninitializedMemory);
            CopyTo(answer.GetPointer());
            return answer;
        }

        public readonly NativeEnumerable<T> ToNativeEnumerable(Allocator allocator)
        {
            var ptr = UnsafeUtilityEx.Malloc<T>(Length, allocator);
            CopyTo(ptr);
            return new NativeEnumerable<T>(ptr, Length);
        }

        private void ReAllocate()
        {
            var tmp = UnsafeUtilityEx.Malloc<T>(Capacity << 1, Allocator);
            CopyTo(tmp);
            UnsafeUtility.Free(Elements, Allocator);
            Elements = tmp;
            Capacity <<= 1;
            StartIndex = 0;
        }

        public void Dispose()
        {
            if (Elements != null && UnsafeUtility.IsValidAllocator(Allocator))
                UnsafeUtility.Free(Elements, Allocator);
            this = default;
        }

        #region Enumerable
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly AppendEnumerable<RingBuffer<T>, Enumerator, T>
            Append(T value, Allocator allocator = Allocator.Temp)
            => new AppendEnumerable<RingBuffer<T>, Enumerator, T>(this, value, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly RingBuffer<T> AsRefEnumerable() => this;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly BufferEnumerable<RingBuffer<T>, Enumerator, T> Buffer(long count)
            => new BufferEnumerable<RingBuffer<T>, Enumerator, T>(this, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DefaultIfEmptyEnumerable<RingBuffer<T>, Enumerator, T>
            DefaultIfEmpty(T defaultValue, Allocator allocator = Allocator.Temp)
            => new DefaultIfEmptyEnumerable<RingBuffer<T>, Enumerator, T>(this, defaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                RingBuffer<T>,
                Enumerator, T, DefaultEqualityComparer<T>, DefaultGetHashCodeFunc<T>>
            Distinct(Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<RingBuffer<T>, Enumerator, T, DefaultEqualityComparer<T>, DefaultGetHashCodeFunc<T>>(this, default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                RingBuffer<T>,
                Enumerator, T, TEqualityComparer0, TGetHashCodeFunc0>
            Distinct<TEqualityComparer0, TGetHashCodeFunc0>(in TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<RingBuffer<T>, Enumerator, T, TEqualityComparer0, TGetHashCodeFunc0>(this, comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TComparer0
            >
            OrderBy<TComparer0>(in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new OrderByEnumerable<RingBuffer<T>, Enumerator, T, TComparer0>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByFromFunc<T>
            >
            OrderBy(Func<T, T, int> comparer, Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<RingBuffer<T>, Enumerator, T, OrderByFromFunc<T>>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByDescending<T, TComparer0>
            >
            OrderByDescending<TComparer0>(in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new OrderByEnumerable<RingBuffer<T>, Enumerator, T, OrderByDescending<T, TComparer0>>(this, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByDescending<T, OrderByFromFunc<T>>
            >
            OrderByDescending(Func<T, T, int> comparer, Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<RingBuffer<T>, Enumerator, T, OrderByDescending<T, OrderByFromFunc<T>>>(this, (OrderByFromFunc<T>)comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
        (
            NativeEnumerable<T> True,
            NativeEnumerable<T> False
        )
        ToPartition(Func<T, bool> predicate, Allocator allocator = Allocator.Temp)
        {

            var True = new NativeList<T>(allocator);
            var False = new NativeList<T>(allocator);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate(enumerator.Current))
                    True.Add(enumerator.Current);
                else
                    False.Add(enumerator.Current);
            }
            enumerator.Dispose();
            return (True.AsNativeEnumerable(), False.AsNativeEnumerable());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
        (
            NativeEnumerable<T> True,
            NativeEnumerable<T> False
        )
        ToPartition<TPredicate0>(in TPredicate0 predicate, Allocator allocator = Allocator.Temp)
            where TPredicate0 : struct, IRefFunc<T, bool>
        {

            var True = new NativeList<T>(allocator);
            var False = new NativeList<T>(allocator);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate.Calc(ref enumerator.Current))
                    True.Add(enumerator.Current);
                else
                    False.Add(enumerator.Current);
            }
            enumerator.Dispose();
            return (True.AsNativeEnumerable(), False.AsNativeEnumerable());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            PrependEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >
            Prepend(T value, Allocator allocator = Allocator.Temp)
            => new PrependEnumerable<RingBuffer<T>, Enumerator, T>(this, value, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ReverseEnumerable<RingBuffer<T>, Enumerator, T>
            Reverse(Allocator allocator = Allocator.Temp)
            => new ReverseEnumerable<RingBuffer<T>, Enumerator, T>(this, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectIndexEnumerable<RingBuffer<T>, Enumerator, T, TNextResult0, TNextAction0>
            SelectIndex<TNextResult0, TNextAction0>(TNextAction0 action, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            where TNextAction0 : struct, ISelectIndex<T, TNextResult0>
            => new SelectIndexEnumerable<RingBuffer<T>, Enumerator, T, TNextResult0, TNextAction0>(this, action, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectIndexEnumerable<RingBuffer<T>, Enumerator, T, TNextResult0, DelegateFuncToSelectIndexStructOperator<T, TNextResult0>>
            SelectIndex<TNextResult0>(Func<T, long, TNextResult0> func, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            => new SelectIndexEnumerable<RingBuffer<T>, Enumerator, T, TNextResult0, DelegateFuncToSelectIndexStructOperator<T, TNextResult0>>(this, func, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectEnumerable<RingBuffer<T>, Enumerator, T, TNextResult0, TNextAction0>
            Select<TNextResult0, TNextAction0>(TNextAction0 action, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            where TNextAction0 : struct, IRefAction<T, TNextResult0>
            => new SelectEnumerable<RingBuffer<T>, Enumerator, T, TNextResult0, TNextAction0>(this, action, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly SelectEnumerable<RingBuffer<T>, Enumerator, T, TNextResult0, DelegateFuncToAction<T, TNextResult0>>
            Select<TNextResult0>(Func<T, TNextResult0> func, Allocator allocator = Allocator.Temp)
            where TNextResult0 : unmanaged
            => new SelectEnumerable<RingBuffer<T>, Enumerator, T, TNextResult0, DelegateFuncToAction<T, TNextResult0>>(this, func, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                TResultAction
            >
            SelectMany<TResult0, TResultEnumerable0, TResultEnumerator0, TResultAction>(TResultAction action)
            where TResult0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<TResult0>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TResult0>
            where TResultAction : struct, IRefAction<T, TResultEnumerable0>
            => new SelectManyEnumerable<RingBuffer<T>, Enumerator, T, TResult0, TResultEnumerable0, TResultEnumerator0, TResultAction>(this, action);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                DelegateFuncToAction<T, TResultEnumerable0>
            >
            SelectMany<TResult0, TResultEnumerable0, TResultEnumerator0>(Func<T, TResultEnumerable0> func)
            where TResult0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<TResult0>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, TResult0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TResult0,
                TResultEnumerable0,
                TResultEnumerator0,
                DelegateFuncToAction<T, TResultEnumerable0>
            >(this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >
            Skip(long count)
            => new SkipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >(this, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipLastEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >
            SkipLast(long count, Allocator allocator = Allocator.Temp)
            => new SkipLastEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >(this, count, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SkipWhileEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TPredicate0
            >
            SkipWhileIndex<TPredicate0>(in TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new SkipWhileEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >
            Take(long count)
            => new TakeEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >(this, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeWhileEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TPredicate0
            >
            TakeWhileIndex<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new TakeWhileEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            TakeLastEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >
            TakeLast(long count, Allocator allocator = Allocator.Temp)
            => new TakeLastEnumerable<
                RingBuffer<T>,
                Enumerator,
                T
            >(this, count, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectIndexEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                (T, long),
                WithIndex<T>
            >
            WithIndex(Allocator allocator = Allocator.Temp)
            => new SelectIndexEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                (T, long),
                WithIndex<T>
            >(this, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TPredicate0
            >
            Where<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new WhereEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DelegateFuncToStructOperatorFunc<T, bool>
            >
            Where(Func<T, bool> predicate)
            => new WhereEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DelegateFuncToStructOperatorFunc<T, bool>
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereIndexEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TPredicate0
            >
            WhereIndex<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IWhereIndex<T>
            => new WhereIndexEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TPredicate0
            >(this, predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            WhereIndexEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DelegateFuncToWhereIndexStructOperator<T>
            >
            WhereIndex(Func<T, long, bool> predicate)
            => new WhereIndexEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DelegateFuncToWhereIndexStructOperator<T>
            >(this, predicate);
        #endregion

        #region Concat
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                TEnumerable1,
                TEnumerator1,
                T
            >
            Concat<TEnumerable1, TEnumerator1>
            (in TEnumerable1 second)
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                TEnumerable1, TEnumerator1,
                T
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T>,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T>.Enumerator,
                T
            >
            Concat<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2>
            (in ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable2 : struct, IRefEnumerable<TEnumerator2, T>
            where TEnumerator2 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T>,
                ConcatEnumerable<TEnumerable1, TEnumerator1, TEnumerable2, TEnumerator2, T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T
            >
            Concat(NativeArray<T> second)
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T
            >(this, second.AsRefEnumerable());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T
            >
            Concat(in NativeEnumerable<T> second)
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                AppendEnumerable<TEnumerable1, TEnumerator1, T>,
                AppendEnumerable<TEnumerable1, TEnumerator1, T>.Enumerator,
                T
            >
            Concat<TEnumerable1, TEnumerator1>
            (in AppendEnumerable<TEnumerable1, TEnumerator1, T> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                AppendEnumerable<TEnumerable1, TEnumerator1, T>,
                AppendEnumerable<TEnumerable1, TEnumerator1, T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T
            >
            Concat(in ArrayEnumerable<T> second)
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T
            >
            Concat(in T[] second)
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T
            >(this, second.AsRefEnumerable());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T>,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T>.Enumerator,
                T
            >
            Concat<TEnumerable1, TEnumerator1>
            (in DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T>,
                DefaultIfEmptyEnumerable<TEnumerable1, TEnumerator1, T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T
            >
            Concat<TEnumerable1, TEnumerator1, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0> second)
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable1, TEnumerator1, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T
            >
            Concat<TKey0>
            (in Grouping<TKey0, T> second)
            where TKey0 : unmanaged
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T
            >
            Concat<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0Selector, TKeyEqualityComparer0>
            (in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>
            second)
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                T>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer0>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer0>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                RangeRepeatEnumerable<T, TAction1>,
                RangeRepeatEnumerable<T, TAction1>.Enumerator,
                T
            >
            Concat<TAction1>
            (in RangeRepeatEnumerable<T, TAction1> second)
            where TAction1 : struct, IRangeRepeat<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                RangeRepeatEnumerable<T, TAction1>,
                RangeRepeatEnumerable<T, TAction1>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T
            >
            Concat
            (in RingBuffer<T> second)
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1>,
                SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1>.Enumerator,
                T
            >
            Concat<TEnumerable1, TEnumerator1, TPrevSource1, TAction1>
            (in SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1> second)
            where TEnumerator1 : struct, IRefEnumerator<TPrevSource1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TPrevSource1>
            where TAction1 : struct, IRefAction<TPrevSource1, T>
            where TPrevSource1 : unmanaged
            => new ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1>,
                    SelectEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1>.Enumerator,
                    T>
                (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1>,
                SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1>.Enumerator,
                T
            >
            Concat<TEnumerable1, TEnumerator1, TPrevSource1, TAction1>
            (in SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1> second)
            where TEnumerator1 : struct, IRefEnumerator<TPrevSource1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, TPrevSource1>
            where TAction1 : struct, ISelectIndex<TPrevSource1, T>
            where TPrevSource1 : unmanaged
            => new ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1>,
                    SelectIndexEnumerable<TEnumerable1, TEnumerator1, TPrevSource1, T, TAction1>.Enumerator,
                    T>
                (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T, TResultEnumerable0, TResultEnumerator0, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T, TResultEnumerable0, TResultEnumerator0, TAction0>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0, TPrevSource0, TResultEnumerable0, TResultEnumerator0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T, TResultEnumerable0, TResultEnumerator0, TAction0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevSource0 : unmanaged
            where TResultEnumerator0 : struct, IRefEnumerator<T>
            where TResultEnumerable0 : struct, IRefEnumerable<TResultEnumerator0, T>
            where TAction0 : struct, IRefAction<TPrevSource0, TResultEnumerable0>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T, TResultEnumerable0, TResultEnumerator0, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T, TResultEnumerable0, TResultEnumerator0, TAction0>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                TEnumerator0,
                T
            >
            Concat<TEnumerable0, TEnumerator0>(in SkipEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                TEnumerator0,
                T
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0>(in TakeEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TEnumerator0,
                T
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TEnumerator0,
                T
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0>(in SkipLastEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0>(in TakeLastEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                UnrolledLinkedList<T>,
                UnrolledLinkedList<T>.Enumerator,
                T
            >
            Concat(in UnrolledLinkedList<T> second)
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                UnrolledLinkedList<T>,
                UnrolledLinkedList<T>.Enumerator,
                T
            >
            (this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0, TPredicate0>(in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T
            >(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0>.Enumerator,
                T
            >
            Concat<TPrevEnumerable0, TPrevEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0> second)
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, T>
            where TPrevEnumerator0 : struct, IRefEnumerator<T>
            where TPredicate0 : struct, IWhereIndex<T>
            => new ConcatEnumerable<RingBuffer<T>, Enumerator, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T, TPredicate0>.Enumerator, T>(this, second);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ConcatEnumerable<
                RingBuffer<T>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                T
            >
            Concat<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => new ConcatEnumerable<RingBuffer<T>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T>(this, second);
        #endregion

        #region Except
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    T,
                    TComparer0
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer0>
            (in TEnumerable0 second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, TEnumerable0, TEnumerator0, T, ExceptOperation<RingBuffer<T>, Enumerator, TEnumerable0, TEnumerator0, T, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, T>, AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, T>, AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in NativeEnumerable<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0>
            (NativeArray<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, TComparer0>>
                (this, second.AsRefEnumerable(), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in ArrayEnumerable<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0>
            (T[] second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, TComparer0>>
                (this, second.AsRefEnumerable(), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TKey0, TComparer0>
            (in Grouping<TKey0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                T>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >(this, second, new ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >(comparer), allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer1 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, T>, PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, T>, PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RangeRepeatEnumerable<T, TAction0>,
                RangeRepeatEnumerable<T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TAction0>
            (in RangeRepeatEnumerable<T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TAction0 : struct, IRangeRepeat<T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, RangeRepeatEnumerable<T, TAction0>, RangeRepeatEnumerable<T, TAction0>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, RangeRepeatEnumerable<T, TAction0>, RangeRepeatEnumerable<T, TAction0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, T>, ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, T>, ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in RingBuffer<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                TEnumerator0,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                TEnumerator0,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TEnumerator0,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TEnumerator0,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                UnrolledLinkedList<T>,
                UnrolledLinkedList<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0>
            (in UnrolledLinkedList<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                UnrolledLinkedList<T>,
                UnrolledLinkedList<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IWhereIndex<T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Except<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T, ExceptOperation<RingBuffer<T>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);
        #endregion

        #region GroupJoin
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    TEnumerable0,
                    TEnumerator0,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    ArrayEnumerable<T0>,
                    ArrayEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    ArrayEnumerable<T0>,
                    ArrayEnumerable<T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                TKey1,
                T1,
                T0Selector,
                TEqualityComparer0
            >(in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            GroupJoin<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<T, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct,
            IRefFunc<T,
                WhereIndexEnumerable<
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    GroupJoinPredicate<T0, TKey1, TKeyEqualityComparer1>
                    >,
                T1>
            =>
            new GroupJoinEnumerable
            <
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable
            <
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            GroupJoin<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<T, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct,
            IRefFunc<T,
                WhereIndexEnumerable<
                    NativeEnumerable<T0>,
                    NativeEnumerable<T0>.Enumerator,
                    T0,
                    GroupJoinPredicate<T0, TKey1, TKeyEqualityComparer1>
                    >,
                T1>
            =>
            new GroupJoinEnumerable
            <
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    RangeRepeatEnumerable<T0, TAction0>,
                    RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TAction0 : struct, IRangeRepeat<T0>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, RangeRepeatEnumerable<T0, TAction0>, RangeRepeatEnumerable<T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            GroupJoin<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new GroupJoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            GroupJoinEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    T,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                    T0,
                    TKey0,
                    TKeySelector0,
                    TKeySelector1,
                    T1,
                    T0Selector,
                    TEqualityComparer0
                >
            GroupJoin<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, WhereIndexEnumerable<NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, GroupJoinPredicate<T0, TKey0, TEqualityComparer0>>, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new GroupJoinEnumerable<RingBuffer<T>, Enumerator, T, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);
        #endregion

        #region Intersect
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    T,
                    TComparer0
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer0>
            (in TEnumerable0 second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, TEnumerable0, TEnumerator0, T, IntersectOperation<RingBuffer<T>, Enumerator, TEnumerable0, TEnumerator0, T, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, T>, AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, AppendEnumerable<TEnumerable0, TEnumerator0, T>, AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in NativeEnumerable<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (NativeArray<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, NativeEnumerable<T>, NativeEnumerable<T>.Enumerator, T, TComparer0>>
                (this, second.AsRefEnumerable(), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in ArrayEnumerable<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (T[] second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, ArrayEnumerable<T>, ArrayEnumerable<T>.Enumerator, T, TComparer0>>
                (this, second.AsRefEnumerable(), comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TKey0, TComparer0>
            (in Grouping<TKey0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                T>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
            second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >(this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer1 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>, OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, T>, PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, PrependEnumerable<TEnumerable0, TEnumerator0, T>, PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RangeRepeatEnumerable<T, TAction0>,
                RangeRepeatEnumerable<T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TAction0>
            (in RangeRepeatEnumerable<T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TAction0 : struct, IRangeRepeat<T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, RangeRepeatEnumerable<T, TAction0>, RangeRepeatEnumerable<T, TAction0>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, RangeRepeatEnumerable<T, TAction0>, RangeRepeatEnumerable<T, TAction0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, T>, ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, ReverseEnumerable<TEnumerable0, TEnumerator0, T>, ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator, T, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0>
            (in RingBuffer<T> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T,
                    TComparer0
                >
            >
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, TComparer0>>
            (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IWhereIndex<T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T,
                    TComparer0
                >
            >
            Intersect<TComparer0, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, in TComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TComparer0 : struct, IRefFunc<T, T, int>
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => new SetOperationEnumerable<RingBuffer<T>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T, IntersectOperation<RingBuffer<T>, Enumerator, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator, T, TComparer0>>
                (this, second, comparer, allocator);
        #endregion

        #region Join
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, NativeEnumerable<T0>, NativeEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, ArrayEnumerable<T0>, ArrayEnumerable<T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TKey1 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<T, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct, IRefFunc<T, T0, T1>
            =>
            new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, in TKeyEqualityComparer1 comparer, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<T, TKey1>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey1>
            where TKeyEqualityComparer1 : struct, IRefFunc<TKey1, TKey1, bool>
            where T1Selector : struct, IRefFunc<T, T0, T1>
            =>
            new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey1,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                TKeyEqualityComparer1
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, RangeRepeatEnumerable<T0, TAction0>, RangeRepeatEnumerable<T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                TEqualityComparer0
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, in TEqualityComparer0 comparer, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<RingBuffer<T>, Enumerator, T, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>, ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector, TEqualityComparer0>
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, comparer, allocator);
        #endregion

        #region Max
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetMax(out T value)
        {
            value = default;
            if (typeof(T) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, byte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, sbyte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, short>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, ushort>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, int>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, uint>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, long>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, ulong>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, float>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, double>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, decimal>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly T Max()
        {
            T value;
            if (typeof(T) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, byte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, sbyte>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, short>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, ushort>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, int>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, uint>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, long>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, ulong>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, float>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, double>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, decimal>(ref current) > max)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
            INITIALIZE:
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var max = ref Unsafe.As<T, decimal?>(ref value);
                if (!max.HasValue) goto INITIALIZE;
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, decimal?>(ref enumerator.Current);
                    if (!current.HasValue || current.Value <= max.Value) continue;
                    max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(byte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(sbyte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(short?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(ushort?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(int?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(uint?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(long?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(ulong?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(float?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(double?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(decimal?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var max = ref Unsafe.As<T, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!max.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                enumerator.Dispose();
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMax<TResult0>(Func<T, TResult0> func, out TResult0 value)
            where TResult0 : unmanaged
        {
            value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current > max)
                        max = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TResult0 Max<TResult0>(Func<T, TResult0> func)
            where TResult0 : unmanaged
        {
            TResult0 value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current > max)
                        max = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var max = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value > max.Value)
                        max = current;
                }
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
        #endregion

        #region MaxByFirst
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, byte> func, out (T value, byte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, byte?> func, out (T value, byte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, byte> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, byte?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            byte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, sbyte> func, out (T value, sbyte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, sbyte?> func, out (T value, sbyte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, sbyte> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, sbyte?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            sbyte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, short> func, out (T value, short key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, short?> func, out (T value, short? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, short> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, short?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            short? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, short?> func)
        {
            var enumerator = GetEnumerator();
            short? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, ushort> func, out (T value, ushort key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, ushort?> func, out (T value, ushort? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, ushort> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, ushort?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ushort? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, int> func, out (T value, int key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, int?> func, out (T value, int? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, int> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, int?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            int? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, int?> func)
        {
            var enumerator = GetEnumerator();
            int? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, uint> func, out (T value, uint key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, uint?> func, out (T value, uint? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, uint> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, uint?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            uint? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, long> func, out (T value, long key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, long?> func, out (T value, long? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, long> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, long?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            long? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, long?> func)
        {
            var enumerator = GetEnumerator();
            long? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, ulong> func, out (T value, ulong key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, ulong?> func, out (T value, ulong? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, ulong> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, ulong?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ulong? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, float> func, out (T value, float key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, float?> func, out (T value, float? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, float> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, float?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            float? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, float?> func)
        {
            var enumerator = GetEnumerator();
            float? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, double> func, out (T value, double key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, double?> func, out (T value, double? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, double> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, double?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            double? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, double?> func)
        {
            var enumerator = GetEnumerator();
            double? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, decimal> func, out (T value, decimal key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, decimal?> func, out (T value, decimal? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, decimal> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByFirst(Func<T, decimal?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            decimal? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByFirst(Func<T, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key <= maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        #endregion

        #region MaxByLast
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, byte> func, out (T value, byte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, byte?> func, out (T value, byte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, byte> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, byte?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            byte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, sbyte> func, out (T value, sbyte key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, sbyte?> func, out (T value, sbyte? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, sbyte> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, sbyte?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            sbyte? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, short> func, out (T value, short key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, short?> func, out (T value, short? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, short> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, short?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            short? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, short?> func)
        {
            var enumerator = GetEnumerator();
            short? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, ushort> func, out (T value, ushort key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, ushort?> func, out (T value, ushort? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, ushort> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, ushort?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ushort? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, int> func, out (T value, int key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, int?> func, out (T value, int? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, int> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, int?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            int? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, int?> func)
        {
            var enumerator = GetEnumerator();
            int? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, uint> func, out (T value, uint key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, uint?> func, out (T value, uint? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, uint> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, uint?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            uint? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, long> func, out (T value, long key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, long?> func, out (T value, long? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, long> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, long?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            long? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, long?> func)
        {
            var enumerator = GetEnumerator();
            long? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, ulong> func, out (T value, ulong key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, ulong?> func, out (T value, ulong? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, ulong> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, ulong?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            ulong? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, float> func, out (T value, float key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, float?> func, out (T value, float? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, float> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, float?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            float? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, float?> func)
        {
            var enumerator = GetEnumerator();
            float? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, double> func, out (T value, double key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, double?> func, out (T value, double? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, double> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, double?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            double? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, double?> func)
        {
            var enumerator = GetEnumerator();
            double? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, decimal> func, out (T value, decimal key) max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max.value = enumerator.Current;
            max.key = func(max.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, decimal?> func, out (T value, decimal? key) max)
        {
            var enumerator = GetEnumerator();
            max = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                max.key = func(enumerator.Current);
            } while (!max.key.HasValue);
            max.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < max.key) continue;
                max.value = value;
                max.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, decimal> func, out T max)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                max = default;
                return false;
            }
            max = enumerator.Current;
            var maxKey = func(max);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMaxByLast(Func<T, decimal?> func, out T max)
        {
            var enumerator = GetEnumerator();
            max = default;
            decimal? maxKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            max = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                max = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var maxVal = enumerator.Current;
            var maxKey = func(maxVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MaxByLast(Func<T, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? maxKey;
            T maxVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                maxKey = func(enumerator.Current);
            } while (!maxKey.HasValue);
            maxVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key < maxKey) continue;
                maxVal = value;
                maxKey = key;
            }
            enumerator.Dispose();
            return maxVal;
        }
        #endregion

        #region Min
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetMin(out T value)
        {
            value = default;
            if (typeof(T) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, byte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, sbyte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, short>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, ushort>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, int>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, uint>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, long>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, ulong>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, float>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, double>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, decimal>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else if (typeof(T) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        return false;
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly T Min()
        {
            T value;
            if (typeof(T) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, byte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, sbyte>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, short>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, ushort>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, int>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, uint>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, long>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, ulong>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, float>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, double>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var current = enumerator.Current;
                    if (Unsafe.As<T, decimal>(ref current) < min)
                        value = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
            INITIALIZE:
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = enumerator.Current;
                ref var min = ref Unsafe.As<T, decimal?>(ref value);
                if (!min.HasValue) goto INITIALIZE;
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, decimal?>(ref enumerator.Current);
                    if (!current.HasValue || current.Value <= min.Value) continue;
                    min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(byte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, byte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, byte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(sbyte?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, sbyte?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, sbyte?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(short?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, short?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, short?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(ushort?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, ushort?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, ushort?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(int?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, int?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, int?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(uint?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, uint?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, uint?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(long?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, long?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, long?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(ulong?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, ulong?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, ulong?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(float?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, float?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, float?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(double?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, double?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, double?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else if (typeof(T) == typeof(decimal?))
            {
                value = default;
                var enumerator = GetEnumerator();
                ref var min = ref Unsafe.As<T, decimal?>(ref value);
                do
                {
                    if (!enumerator.MoveNext())
                    {
                        enumerator.Dispose();
                        throw new InvalidOperationException();
                    }
                    value = enumerator.Current;
                } while (!min.HasValue);
                while (enumerator.MoveNext())
                {
                    var current = Unsafe.As<T, decimal?>(ref enumerator.Current);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                enumerator.Dispose();
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMin<TResult0>(Func<T, TResult0> func, out TResult0 value)
            where TResult0 : unmanaged
        {
            value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current < min)
                        min = current;
                }
                return true;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TResult0 Min<TResult0>(Func<T, TResult0> func)
            where TResult0 : unmanaged
        {
            TResult0 value = default;
            if (typeof(TResult0) == typeof(byte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(byte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, byte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, byte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(sbyte))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(sbyte?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, sbyte?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, sbyte?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(short))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(short?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, short?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, short?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ushort))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ushort?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ushort?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ushort?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(int))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(int?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, int?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, int?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(uint))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(uint?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, uint?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, uint?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(long))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(long?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, long?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, long?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(ulong))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(ulong?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, ulong?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, ulong?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(float))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(float?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, float?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, float?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(double))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(double?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, double?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, double?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            if (typeof(TResult0) == typeof(decimal))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal>(ref result);
                    if (current < min)
                        min = current;
                }
                return value;
            }
            else if (typeof(TResult0) == typeof(decimal?))
            {
                var enumerator = GetEnumerator();
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                value = func(enumerator.Current);
                ref var min = ref Unsafe.As<TResult0, decimal?>(ref value);
                while (enumerator.MoveNext())
                {
                    var result = func(enumerator.Current);
                    ref var current = ref Unsafe.As<TResult0, decimal?>(ref result);
                    if (current.HasValue && current.Value < min.Value)
                        min = current;
                }
                return value;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }
        #endregion

        #region MinByFirst
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, byte> func, out (T value, byte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, byte?> func, out (T value, byte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, byte> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, byte?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            byte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, sbyte> func, out (T value, sbyte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, sbyte?> func, out (T value, sbyte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, sbyte> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, sbyte?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            sbyte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, short> func, out (T value, short key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, short?> func, out (T value, short? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, short> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, short?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            short? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, short?> func)
        {
            var enumerator = GetEnumerator();
            short? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, ushort> func, out (T value, ushort key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, ushort?> func, out (T value, ushort? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, ushort> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, ushort?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ushort? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, int> func, out (T value, int key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, int?> func, out (T value, int? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, int> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, int?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            int? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, int?> func)
        {
            var enumerator = GetEnumerator();
            int? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, uint> func, out (T value, uint key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, uint?> func, out (T value, uint? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, uint> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, uint?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            uint? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, long> func, out (T value, long key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, long?> func, out (T value, long? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, long> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, long?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            long? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, long?> func)
        {
            var enumerator = GetEnumerator();
            long? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, ulong> func, out (T value, ulong key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, ulong?> func, out (T value, ulong? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, ulong> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, ulong?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ulong? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, float> func, out (T value, float key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, float?> func, out (T value, float? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, float> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, float?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            float? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, float?> func)
        {
            var enumerator = GetEnumerator();
            float? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, double> func, out (T value, double key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, double?> func, out (T value, double? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, double> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, double?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            double? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, double?> func)
        {
            var enumerator = GetEnumerator();
            double? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, decimal> func, out (T value, decimal key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, decimal?> func, out (T value, decimal? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, decimal> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByFirst(Func<T, decimal?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            decimal? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByFirst(Func<T, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key >= minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        #endregion

        #region MinByLast
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, byte> func, out (T value, byte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, byte?> func, out (T value, byte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, byte> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, byte?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            byte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, byte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, byte?> func)
        {
            var enumerator = GetEnumerator();
            byte? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, sbyte> func, out (T value, sbyte key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, sbyte?> func, out (T value, sbyte? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, sbyte> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, sbyte?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            sbyte? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, sbyte> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, sbyte?> func)
        {
            var enumerator = GetEnumerator();
            sbyte? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, short> func, out (T value, short key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, short?> func, out (T value, short? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, short> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, short?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            short? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, short> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, short?> func)
        {
            var enumerator = GetEnumerator();
            short? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, ushort> func, out (T value, ushort key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, ushort?> func, out (T value, ushort? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, ushort> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, ushort?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ushort? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, ushort> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, ushort?> func)
        {
            var enumerator = GetEnumerator();
            ushort? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, int> func, out (T value, int key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, int?> func, out (T value, int? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, int> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, int?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            int? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, int> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, int?> func)
        {
            var enumerator = GetEnumerator();
            int? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, uint> func, out (T value, uint key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, uint?> func, out (T value, uint? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, uint> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, uint?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            uint? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, uint> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, uint?> func)
        {
            var enumerator = GetEnumerator();
            uint? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, long> func, out (T value, long key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, long?> func, out (T value, long? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, long> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, long?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            long? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, long> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, long?> func)
        {
            var enumerator = GetEnumerator();
            long? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, ulong> func, out (T value, ulong key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, ulong?> func, out (T value, ulong? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, ulong> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, ulong?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            ulong? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, ulong> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, ulong?> func)
        {
            var enumerator = GetEnumerator();
            ulong? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, float> func, out (T value, float key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, float?> func, out (T value, float? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, float> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, float?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            float? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, float> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, float?> func)
        {
            var enumerator = GetEnumerator();
            float? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, double> func, out (T value, double key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, double?> func, out (T value, double? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, double> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, double?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            double? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, double> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, double?> func)
        {
            var enumerator = GetEnumerator();
            double? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, decimal> func, out (T value, decimal key) min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min.value = enumerator.Current;
            min.key = func(min.value);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, decimal?> func, out (T value, decimal? key) min)
        {
            var enumerator = GetEnumerator();
            min = default;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                min.key = func(enumerator.Current);
            } while (!min.key.HasValue);
            min.value = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > min.key) continue;
                min.value = value;
                min.key = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, decimal> func, out T min)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                min = default;
                return false;
            }
            min = enumerator.Current;
            var minKey = func(min);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryGetMinByLast(Func<T, decimal?> func, out T min)
        {
            var enumerator = GetEnumerator();
            min = default;
            decimal? minKey;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    return false;
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            min = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                min = value;
                minKey = key;
            }
            enumerator.Dispose();
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, decimal> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var minVal = enumerator.Current;
            var minKey = func(minVal);
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T MinByLast(Func<T, decimal?> func)
        {
            var enumerator = GetEnumerator();
            decimal? minKey;
            T minVal;
            do
            {
                if (!enumerator.MoveNext())
                {
                    enumerator.Dispose();
                    throw new InvalidOperationException();
                }
                minKey = func(enumerator.Current);
            } while (!minKey.HasValue);
            minVal = enumerator.Current;
            while (enumerator.MoveNext())
            {
                ref var value = ref enumerator.Current;
                var key = func(value);
                if (!key.HasValue || key > minKey) continue;
                minVal = value;
                minKey = key;
            }
            enumerator.Dispose();
            return minVal;
        }
        #endregion

        public
            MinMaxByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                MinByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            MinBy<TKey0>(Func<T, TKey0> func)
            where TKey0 : unmanaged
            => new MinMaxByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                MinByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            (this, func, default, default);

        public
            MinMaxByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                MaxByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            MaxBy<TKey0>(Func<T, TKey0> func)
            where TKey0 : unmanaged
            => new MinMaxByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                MaxByPredicate<TKey0, DefaultOrderByAscending<TKey0>>,
                DefaultEqualityComparer<TKey0>
            >
            (this, func, default, default);

        #region Union
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator, TEnumerable0, TEnumerator0, T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator, TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TEnumerable0 second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<ConcatEnumerable<RingBuffer<T>, Enumerator, TEnumerable0, TEnumerator0, T>, ConcatEnumerable<RingBuffer<T>, Enumerator, TEnumerable0, TEnumerator0, T>.Enumerator, T, TEqualityComparer0, TGetHashCodeFunc0>
                (Concat<TEnumerable0, TEnumerator0>(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T>
                    second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in NativeEnumerable<T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (NativeArray<T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second.AsRefEnumerable()), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in ArrayEnumerable<T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (T[]
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second.AsRefEnumerable()), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, TGetHashCodeFunc0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TEqualityComparer1, TGetHashCodeFunc1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TEqualityComparer1 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc1 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TKey0>
            (in Grouping<TKey0, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(in second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<RingBuffer<T>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
                ConcatEnumerable<RingBuffer<T>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                T>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<RingBuffer<T>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
                ConcatEnumerable<RingBuffer<T>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<RingBuffer<T>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
                ConcatEnumerable<RingBuffer<T>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<RingBuffer<T>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
                ConcatEnumerable<RingBuffer<T>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TAction0, TEqualityComparer0, TGetHashCodeFunc0>
            (in RangeRepeatEnumerable<T, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in RingBuffer<T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TPrevEnumerable0, TPrevEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPrevSource0, TAction0>
            (in SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TPrevEnumerable0, TPrevEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, ISelectIndex<TPrevSource0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, T0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
            => new DistinctEnumerable<ConcatEnumerable<RingBuffer<T>, Enumerator, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator, T>, ConcatEnumerable<RingBuffer<T>, Enumerator, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator, T>.Enumerator, T, TEqualityComparer0, TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEqualityComparer0, TGetHashCodeFunc0>
            (in UnrolledLinkedList<T>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0
            >
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IWhereIndex<T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>
                second, TEqualityComparer0 comparer, TGetHashCodeFunc0 getHashCodeFunc, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                TEqualityComparer0,
                TGetHashCodeFunc0>
            (Concat(second), comparer, getHashCodeFunc, allocator);
        #endregion

        #region SequenceEqual
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TEnumerable0 second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
        {
            var enumerator0 = GetEnumerator();
            var enumerator1 = second.GetEnumerator();
            while (true)
            {
                var b = enumerator0.MoveNext();
                if (b ^ enumerator1.MoveNext())
                {
                    enumerator0.Dispose();
                    enumerator1.Dispose();
                    return false;
                }
                if (!b)
                {
                    enumerator0.Dispose();
                    enumerator1.Dispose();
                    return true;
                }
                if (!comparer.Calc(ref enumerator0.Current, ref enumerator1.Current)) return false;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => SequenceEqual<
                TEnumerable0, TEnumerator0,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => SequenceEqual<
                AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in NativeEnumerable<T> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in NativeEnumerable<T> second)
            => SequenceEqual<
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in NativeArray<T> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                TEqualityComparer0
            >(second.AsRefEnumerable(), comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in NativeArray<T> second)
            => SequenceEqual<
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second.AsRefEnumerable(), default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in ArrayEnumerable<T> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(in ArrayEnumerable<T> second)
            => SequenceEqual<
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (T[] second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                TEqualityComparer0
            >(second.AsRefEnumerable(), comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual(T[] second)
            => SequenceEqual<
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second.AsRefEnumerable(), default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            => SequenceEqual<
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => SequenceEqual<
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TEqualityComparer1, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TEqualityComparer1 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => SequenceEqual<
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0, TKey0>
            (in Grouping<TKey0, T> second, in TEqualityComparer0 comparer)
            where TKey0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                TEqualityComparer0
            >
            (second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer1, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer1 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => SequenceEqual<
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            => SequenceEqual<
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                T>
            => SequenceEqual<
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            => SequenceEqual<
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => SequenceEqual<
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => SequenceEqual<
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => SequenceEqual<
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0, TAction0>
            (in RangeRepeatEnumerable<T, TAction0> second, in TEqualityComparer0 comparer)
            where TAction0 : struct, IRangeRepeat<T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                RangeRepeatEnumerable<T, TAction0>,
                RangeRepeatEnumerable<T, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TAction0>
            (in RangeRepeatEnumerable<T, TAction0> second)
            where TAction0 : struct, IRangeRepeat<T>
            => SequenceEqual<

                RangeRepeatEnumerable<T, TAction0>,
                RangeRepeatEnumerable<T, TAction0>.Enumerator,

                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => SequenceEqual<
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in RingBuffer<T> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual
            (in RingBuffer<T> second)
            => SequenceEqual<
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, T>
            => SequenceEqual<
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, T>
            => SequenceEqual<
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<T0, T>
            => SequenceEqual<
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<T0, T>
            => SequenceEqual<
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, T0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => SequenceEqual<
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0> second)
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => SequenceEqual<
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
            => SequenceEqual<
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
            => SequenceEqual<
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                TEnumerator0,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => SequenceEqual<
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TEnumerator0,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => SequenceEqual<
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEqualityComparer0>
            (in UnrolledLinkedList<T> second, in TEqualityComparer0 comparer)
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            => SequenceEqual<
                UnrolledLinkedList<T>,
                UnrolledLinkedList<T>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => SequenceEqual<
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => SequenceEqual<
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEqualityComparer0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, in TEqualityComparer0 comparer)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TPredicate0 : struct, IWhereIndex<T>
            => SequenceEqual<
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IWhereIndex<T>
            => SequenceEqual<
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TEqualityComparer0, T0, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, in TEqualityComparer0 comparer)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => SequenceEqual<
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                TEqualityComparer0
            >(second, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool
            SequenceEqual<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => SequenceEqual<
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                DefaultEqualityComparer<T>
            >(second, default);
        #endregion

        #region Zip
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TEnumerable0 second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >(this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>, AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TResult0, TAction0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TKey0, T0, TResult0, TAction0>
            (in Grouping<TKey0, T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult0, TAction0>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, TAction0 action, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<T, T2, TResult0>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult0, TAction0>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, TAction0 action, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<T, T2, TResult0>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>, PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction1>,
                RangeRepeatEnumerable<T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0, TAction1>
            (in RangeRepeatEnumerable<T0, TAction1>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRangeRepeat<T0>
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, RangeRepeatEnumerable<T0, TAction1>, RangeRepeatEnumerable<T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator, T0, TResult0, TAction0>(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0>
            (in RingBuffer<T0>
                second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TAction1>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>, SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TAction1>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>, SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPrevSource0, TEnumerable1, TEnumerator1, TAction1>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TAction1 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction1>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0, TResult0, TAction0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>, SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<T0, TResult0, TAction0>
            (in UnrolledLinkedList<T0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult0, TAction0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, TAction0 action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<T, T0, TResult0>
            where TResult0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>, WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator, T0, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>.Enumerator,
                TResult1,
                TResult0,
                TAction0
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TResult1, TAction0, TAction1>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>
            second, TAction0 action, T firstDefaultValue = default, TResult1 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TAction1 : struct, IRefAction<T0, T1, TResult1>
            where TResult0 : unmanaged
            where TResult1 : unmanaged
            where TAction0 : struct, IRefAction<T, TResult1, TResult0>
            => new ZipEnumerable<RingBuffer<T>, Enumerator, T, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>, ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult1, TAction1>.Enumerator, TResult1, TResult0, TAction0>
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);
        #endregion

        #region Zip ValueTuple
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TEnumerable0 second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TKey0, T0>
            (in Grouping<TKey0, T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (T, T2),
                ZipValueTuple<T, T2>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (T, T2),
                ZipValueTuple<T, T2>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (T, T2),
                ZipValueTuple<T, T2>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                (T, T2),
                ZipValueTuple<T, T2>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >(this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<T0, TAction0>
            (in RangeRepeatEnumerable<T0, TAction0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<T0>
            (in RingBuffer<T0>
                second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<T0>
            (in UnrolledLinkedList<T0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                (T, T0),
                ZipValueTuple<T, T0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                (T, TResult0),
                ZipValueTuple<T, TResult0>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            second, T firstDefaultValue = default, TResult0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TResult0 : unmanaged
            where TAction0 : struct, IRefAction<T0, T1, TResult0>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                (T, TResult0),
                ZipValueTuple<T, TResult0>
            >
            (this, second, default, firstDefaultValue, secondDefaultValue, allocator);
        #endregion

        #region Function
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Any<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<T, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!predicate.Calc(ref enumerator.Current)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Any(Func<T, bool> predicate)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!predicate(enumerator.Current)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool All<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<T, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate.Calc(ref enumerator.Current)) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool All(Func<T, bool> predicate)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (predicate(enumerator.Current)) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly void Aggregate<TAccumulate0, TFunc0>(ref TAccumulate0 seed, TFunc0 func)
            where TFunc0 : struct, IRefAction<TAccumulate0, T>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                func.Execute(ref seed, ref enumerator.Current);
            enumerator.Dispose();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TNextResult0 Aggregate<TAccumulate0, TNextResult0, TFunc0, TResultFunc0>(ref TAccumulate0 seed, TFunc0 func, TResultFunc0 resultFunc)
            where TFunc0 : struct, IRefAction<TAccumulate0, T>
            where TResultFunc0 : struct, IRefFunc<TAccumulate0, TNextResult0>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                func.Execute(ref seed, ref enumerator.Current);
            enumerator.Dispose();
            return resultFunc.Calc(ref seed);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly T Aggregate(Func<T, T, T> func)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                throw new InvalidOperationException();
            }
            var seed = enumerator.Current;
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return seed;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TAccumulate0 Aggregate<TAccumulate0>(TAccumulate0 seed, Func<TAccumulate0, T, TAccumulate0> func)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return seed;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly TNextResult0 Aggregate<TAccumulate0, TNextResult0>(TAccumulate0 seed, Func<TAccumulate0, T, TAccumulate0> func, Func<TAccumulate0, TNextResult0> resultFunc)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                seed = func(seed, enumerator.Current);
            enumerator.Dispose();
            return resultFunc(seed);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(in T value) => Contains(in value, EqualityComparer<T>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(T value) => Contains(in value, EqualityComparer<T>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(in T value, IEqualityComparer<T> comparer)
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!comparer.Equals(enumerator.Current, value)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(T value, IEqualityComparer<T> comparer) => Contains(in value, comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains<TComparer0>(ref T value, ref TComparer0 comparer)
        where TComparer0 : struct, IRefFunc<T, T, bool>
        {
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                if (!comparer.Calc(ref enumerator.Current, ref value)) continue;
                enumerator.Dispose();
                return true;
            }
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains<TComparer0>(T value, TComparer0 comparer)
            where TComparer0 : struct, IRefFunc<T, T, bool>
            => Contains(ref value, ref comparer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Count(Func<T, bool> predicate)
            => (int)LongCount(predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly int Count<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<T, bool>
            => (int)LongCount(predicate);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly long LongCount(Func<T, bool> predicate)
        {
            var enumerator = GetEnumerator();
            var count = 0L;
            while (enumerator.MoveNext())
                if (predicate(enumerator.Current))
                    ++count;
            enumerator.Dispose();
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly long LongCount<TPredicate0>(TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<T, bool>
        {
            var enumerator = GetEnumerator();
            var count = 0L;
            while (enumerator.MoveNext())
                if (predicate.Calc(ref enumerator.Current))
                    ++count;
            enumerator.Dispose();
            return count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetElementAt(long index, out T value)
        {
            if (index < 0)
            {
                value = default;
                return false;
            }
            var enumerator = GetEnumerator();
            for (var i = 0L; i < index; i++)
            {
                if (enumerator.MoveNext()) continue;
                value = default;
                enumerator.Dispose();
                return false;
            }
            value = enumerator.Current;
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetFirst(out T first)
        {
            var enumerator = GetEnumerator();
            if (enumerator.MoveNext())
            {
                first = enumerator.Current;
                enumerator.Dispose();
                return true;
            }
            first = default;
            enumerator.Dispose();
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetLast(out T last)
        {
            var enumerator = GetEnumerator();
            last = default;
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return false;
            }
            while (enumerator.MoveNext())
                last = enumerator.Current;
            enumerator.Dispose();
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle(out T value)
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle<TPredicate0>(out T value, TPredicate0 predicate)
            where TPredicate0 : struct, IRefFunc<T, bool>
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                if (!predicate.Calc(ref enumerator.Current)) continue;
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool TryGetSingle(out T value, Func<T, bool> predicate)
        {
            value = default;
            var enumerator = GetEnumerator();
            var count = 0;
            while (enumerator.MoveNext())
            {
                if (!predicate(enumerator.Current)) continue;
                value = enumerator.Current;
                if (++count <= 1) continue;
                enumerator.Dispose();
                return false;
            }
            enumerator.Dispose();
            return count == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Dictionary<TKey0, TElement0> ToDictionary<TKey0, TElement0>(Func<T, TKey0> keySelector, Func<T, TElement0> elementSelector)
        {
            var answer = new Dictionary<TKey0, TElement0>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                ref var current = ref enumerator.Current;
                answer.Add(keySelector(current), elementSelector(current));
            }
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Dictionary<TKey0, TElement0> ToDictionary<TKey0, TElement0, TKey0Func, TElement0Func>(TKey0Func keySelector, TElement0Func elementSelector)
            where TKey0Func : struct, IRefFunc<T, TKey0>
            where TElement0Func : struct, IRefFunc<T, TElement0>
        {
            var answer = new Dictionary<TKey0, TElement0>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
            {
                ref var current = ref enumerator.Current;
                answer.Add(keySelector.Calc(ref current), elementSelector.Calc(ref current));
            }
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly HashSet<T> ToHashSet()
        {
            var answer = new HashSet<T>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly HashSet<T> ToHashSet(IEqualityComparer<T> comparer)
        {
            var answer = new HashSet<T>(comparer);
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly List<T> ToList()
        {
            var answer = new List<T>();
            var enumerator = GetEnumerator();
            while (enumerator.MoveNext())
                answer.Add(enumerator.Current);
            enumerator.Dispose();
            return answer;
        }
        #endregion

        #region Sum
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            T
            Sum()
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                enumerator.Dispose();
                return default;
            }
            if (typeof(T) == typeof(byte))
            {
                var sum = Unsafe.As<T, byte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, byte>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<byte, T>(ref sum);
            }
            else if (typeof(T) == typeof(sbyte))
            {
                var sum = Unsafe.As<T, sbyte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, sbyte>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<sbyte, T>(ref sum);
            }
            else if (typeof(T) == typeof(short))
            {
                var sum = Unsafe.As<T, short>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, short>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<short, T>(ref sum);
            }
            else if (typeof(T) == typeof(ushort))
            {
                var sum = Unsafe.As<T, ushort>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, ushort>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<ushort, T>(ref sum);
            }
            else if (typeof(T) == typeof(int))
            {
                var sum = Unsafe.As<T, int>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, int>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<int, T>(ref sum);
            }
            else if (typeof(T) == typeof(uint))
            {
                var sum = Unsafe.As<T, uint>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, uint>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<uint, T>(ref sum);
            }
            else if (typeof(T) == typeof(long))
            {
                var sum = Unsafe.As<T, long>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, long>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<long, T>(ref sum);
            }
            else if (typeof(T) == typeof(ulong))
            {
                var sum = Unsafe.As<T, ulong>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, ulong>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<ulong, T>(ref sum);
            }
            else if (typeof(T) == typeof(float))
            {
                var sum = Unsafe.As<T, float>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, float>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<float, T>(ref sum);
            }
            else if (typeof(T) == typeof(double))
            {
                var sum = Unsafe.As<T, double>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, double>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<double, T>(ref sum);
            }
            else if (typeof(T) == typeof(decimal))
            {
                var sum = Unsafe.As<T, decimal>(ref enumerator.Current);
                while (enumerator.MoveNext())
                    sum += Unsafe.As<T, decimal>(ref enumerator.Current);
                enumerator.Dispose();
                return Unsafe.As<decimal, T>(ref sum);
            }
            return default;
        }
        #endregion

        #region Average
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            bool
            TryGetAverage(out T value)
        {
            var enumerator = GetEnumerator();
            if (!enumerator.MoveNext())
            {
                value = default;
                enumerator.Dispose();
                return false;
            }
            var count = 1L;
            if (typeof(T) == typeof(byte))
            {
                long sum = Unsafe.As<T, byte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, byte>(ref enumerator.Current);
                }
                var val = (byte)(sum / count);
                value = Unsafe.As<byte, T>(ref val);
            }
            else if (typeof(T) == typeof(sbyte))
            {
                long sum = Unsafe.As<T, sbyte>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, sbyte>(ref enumerator.Current);
                }
                var val = (sbyte)(sum / count);
                value = Unsafe.As<sbyte, T>(ref val);
            }
            else if (typeof(T) == typeof(short))
            {
                long sum = Unsafe.As<T, short>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, short>(ref enumerator.Current);
                }
                var val = (short)(sum / count);
                value = Unsafe.As<short, T>(ref val);
            }
            else if (typeof(T) == typeof(ushort))
            {
                long sum = Unsafe.As<T, ushort>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, ushort>(ref enumerator.Current);
                }
                var val = (ushort)(sum / count);
                value = Unsafe.As<ushort, T>(ref val);
            }
            else if (typeof(T) == typeof(int))
            {
                long sum = Unsafe.As<T, int>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, int>(ref enumerator.Current);
                }
                var val = (int)(sum / count);
                value = Unsafe.As<int, T>(ref val);
            }
            else if (typeof(T) == typeof(uint))
            {
                long sum = Unsafe.As<T, uint>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, uint>(ref enumerator.Current);
                }
                var val = (uint)(sum / count);
                value = Unsafe.As<uint, T>(ref val);
            }
            else if (typeof(T) == typeof(long))
            {
                var sum = Unsafe.As<T, long>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, long>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<long, T>(ref sum);
            }
            else if (typeof(T) == typeof(ulong))
            {
                var sum = Unsafe.As<T, ulong>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, ulong>(ref enumerator.Current);
                }
                sum /= (ulong)count;
                value = Unsafe.As<ulong, T>(ref sum);
            }
            else if (typeof(T) == typeof(float))
            {
                var sum = Unsafe.As<T, float>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, float>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<float, T>(ref sum);
            }
            else if (typeof(T) == typeof(double))
            {
                var sum = Unsafe.As<T, double>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, double>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<double, T>(ref sum);
            }
            else if (typeof(T) == typeof(decimal))
            {
                var sum = Unsafe.As<T, decimal>(ref enumerator.Current);
                while (enumerator.MoveNext())
                {
                    ++count;
                    sum += Unsafe.As<T, decimal>(ref enumerator.Current);
                }
                sum /= count;
                value = Unsafe.As<decimal, T>(ref sum);
            }
            else
            {
                value = enumerator.Current;
            }
            enumerator.Dispose();
            return true;
        }
        #endregion

        #region OrderByDefault
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultOrderByAscending<T>
            >
            OrderBy(Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<RingBuffer<T>, Enumerator, T, DefaultOrderByAscending<T>>(this, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            OrderByEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultOrderByDescending<T>
            >
            OrderByDescending(Allocator allocator = Allocator.Temp)
            => new OrderByEnumerable<RingBuffer<T>, Enumerator, T, DefaultOrderByDescending<T>>(this, default, allocator);
        #endregion

        #region Union Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator, TEnumerable0, TEnumerator0, T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator, TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator, TEnumerable0, TEnumerator0, T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator, TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat<TEnumerable0, TEnumerator0>(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T>
                    second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                    ConcatEnumerable<
                        RingBuffer<T>,
                        Enumerator,
                        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                        T>,
                    ConcatEnumerable<
                        RingBuffer<T>,
                        Enumerator,
                        AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                        AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                        T>.Enumerator,
                    T,
                    DefaultEqualityComparer<T>,
                    DefaultGetHashCodeFunc<T>
                >
                (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union
            (in NativeEnumerable<T>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union
            (NativeArray<T>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union
            (in ArrayEnumerable<T>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union
            (T[]
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(NativeEnumerable.AsRefEnumerable(second)), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0, TEqualityComparer1, TGetHashCodeFunc1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer1 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc1 : struct, IRefFunc<T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer1, TGetHashCodeFunc1>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0, TKey0>
            (in Grouping<TKey0, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TKey0 : unmanaged
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(in second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<RingBuffer<T>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
                ConcatEnumerable<RingBuffer<T>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                T>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<RingBuffer<T>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
                ConcatEnumerable<RingBuffer<T>, Enumerator, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<RingBuffer<T>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
                ConcatEnumerable<RingBuffer<T>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<RingBuffer<T>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>,
                ConcatEnumerable<RingBuffer<T>, Enumerator, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>, JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator, T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0, TComparer0>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer0 : struct, IRefFunc<T, T, int>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TAction0>
            (in RangeRepeatEnumerable<T, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union
            (in RingBuffer<T>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TAction0>
            (in SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TAction0>
            (in SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TAction0 : struct, ISelectIndex<TPrevSource0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>,
                    SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, TAction0>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TAction0 : struct, IRefAction<T0, TEnumerable1>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>,
                    SelectManyEnumerable<TEnumerable0, TEnumerator0, T0, T, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>,
                    SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T, TSetOperation0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipEnumerable<TEnumerable0, TEnumerator0, T>,
                    TEnumerator0,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TEnumerator0,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    TakeWhileEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    SkipLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>,
                    TakeLastEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union
            (in UnrolledLinkedList<T>
                second, Allocator allocator = Allocator.Temp)
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    UnrolledLinkedList<T>,
                    UnrolledLinkedList<T>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>
            >
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>
                second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IWhereIndex<T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            Union<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>
                second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => new DistinctEnumerable<
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T>,
                ConcatEnumerable<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T>.Enumerator,
                T,
                DefaultEqualityComparer<T>,
                DefaultGetHashCodeFunc<T>>
            (Concat(second), default, default, allocator);
        #endregion

        #region Intersect Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect
            (in NativeEnumerable<T> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
           (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect
            (NativeArray<T> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect
            (in ArrayEnumerable<T> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect
            (T[] second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
           (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TKey0>
            (in Grouping<TKey0, T> second, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                T>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer1 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RangeRepeatEnumerable<T, TAction0>,
                RangeRepeatEnumerable<T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TAction0>
            (in RangeRepeatEnumerable<T, TAction0> second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RangeRepeatEnumerable<T, TAction0>,
                RangeRepeatEnumerable<T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect
            (in RingBuffer<T> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IWhereIndex<T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Intersect<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                T,
                IntersectOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);
        #endregion

        #region Except Default
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in TEnumerable0 second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                TEnumerable0,
                TEnumerator0,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    TEnumerable0,
                    TEnumerator0,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>,
                    AppendEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except
            (in NativeEnumerable<T> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
           (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except
            (NativeArray<T> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                NativeEnumerable<T>,
                NativeEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    NativeEnumerable<T>,
                    NativeEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except
            (in ArrayEnumerable<T> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except
            (T[] second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ArrayEnumerable<T>,
                ArrayEnumerable<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ArrayEnumerable<T>,
                    ArrayEnumerable<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
           (this, NativeEnumerable.AsRefEnumerable(second), default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEnumerator1 : struct, IRefEnumerator<T>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>,
                    ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>,
                    DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>,
                    DistinctEnumerable<TEnumerable0, TEnumerator0, T, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TKey0>
            (in Grouping<TKey0, T> second, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                Grouping<TKey0, T>,
                Grouping<TKey0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    Grouping<TKey0, T>,
                    Grouping<TKey0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct,
            IRefFunc<T0,
                WhereIndexEnumerable<
                    NativeEnumerable<T1>,
                    NativeEnumerable<T1>.Enumerator,
                    T1,
                    GroupJoinPredicate<T1, TKey0, TEqualityComparer1>
                    >,
                T>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TEqualityComparer0, TGetHashCodeFunc0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>
            second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEqualityComparer0 : struct, IRefFunc<T, T, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T, int>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where T0Selector : struct, IRefFunc<T0, T1, T>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>,
                    JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T, T0Selector, TEqualityComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >(this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, TComparer1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TComparer1 : struct, IRefFunc<T, T, int>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>,
                    OrderByEnumerable<TEnumerable0, TEnumerator0, T, TComparer1>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>,
                    PrependEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RangeRepeatEnumerable<T, TAction0>,
                RangeRepeatEnumerable<T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TAction0>
            (in RangeRepeatEnumerable<T, TAction0> second, Allocator allocator = Allocator.Temp)
            where TAction0 : struct, IRangeRepeat<T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RangeRepeatEnumerable<T, TAction0>,
                RangeRepeatEnumerable<T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RangeRepeatEnumerable<T, TAction0>,
                    RangeRepeatEnumerable<T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>,
                    ReverseEnumerable<TEnumerable0, TEnumerator0, T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except
            (in RingBuffer<T> second, Allocator allocator = Allocator.Temp)
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                RingBuffer<T>,
                RingBuffer<T>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    RingBuffer<T>,
                    RingBuffer<T>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, IRefAction<T0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TAction0>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TAction0 : struct, ISelectIndex<T0, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>,
                    SelectIndexEnumerable<TEnumerable0, TEnumerator0, T0, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IRefFunc<T, bool>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, TPredicate0>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0> second, Allocator allocator = Allocator.Temp)
            where TEnumerator0 : struct, IRefEnumerator<T>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T>
            where TPredicate0 : struct, IWhereIndex<T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>,
                    WhereIndexEnumerable<TEnumerable0, TEnumerator0, T, TPredicate0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            Except<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TAction0>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0> second, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where T1 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TAction0 : struct, IRefAction<T0, T1, T>
            => new SetOperationEnumerable<
                RingBuffer<T>,
                Enumerator,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                T,
                ExceptOperation<
                    RingBuffer<T>,
                    Enumerator,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>,
                    ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, T, TAction0>.Enumerator,
                    T,
                    DefaultOrderByAscending<T>
                >
            >
            (this, second, default, allocator);
        #endregion

        #region Join
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TEnumerable0 inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in NativeEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (NativeArray<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in ArrayEnumerable<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (T0[] inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TKey1 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1, TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector>
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TEqualityComparer1 : struct, IRefFunc<TKey2, TKey2, bool>
            where T0Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey2, TEqualityComparer1>
                    >,
                T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<T, TKey0>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T1Selector : struct, IRefFunc<T, T0, T1>
            =>
            new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0, TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector>
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>
                inner,
                in TOuterKeySelector1 outerKeySelector, in TInnerKeySelector1 innerKeySelector,
                in T1Selector resultSelector, Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey2, TKey2, bool>
            where T0Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            where TOuterKeySelector1 : struct, IRefFunc<T, TKey0>
            where TInnerKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T1Selector : struct, IRefFunc<T, T0, T1>
            =>
            new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T0Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                TOuterKeySelector1,
                TInnerKeySelector1,
                T1,
                T1Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in RingBuffer<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
            >
            (in UnrolledLinkedList<T0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeySelector1, T1, T0Selector
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in TKeySelector0 outerKeySelector, in TKeySelector1 innerKeySelector, in T0Selector resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T, TKey0>
            where TKeySelector1 : struct, IRefFunc<T0, TKey0>
            where T0Selector : struct, IRefFunc<T, T0, T1>
            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                TKeySelector0,
                TKeySelector1,
                T1,
                T0Selector,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);
        #endregion

        #region Join Default Func
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TEnumerable0 inner, in Func<T, TKey0> outerKeySelector, in Func<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in NativeEnumerable<T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (NativeArray<T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in ArrayEnumerable<T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (T0[] inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner.AsRefEnumerable(), outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1
            >
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEqualityComparer1, TGetHashCodeFunc0
            >
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEqualityComparer1 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer1, TGetHashCodeFunc0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TKey1
            >
            (in Grouping<TKey1, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKey1 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey1, T0>,
                Grouping<TKey1, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, TSetOperation0
            >
            (in SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                > inner,
            in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >,
                SetOperationEnumerable<
                    TEnumerable0,
                    TEnumerator0,
                    TEnumerable1,
                    TEnumerator1,
                    T0,
                    TSetOperation0
                >.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1, TKey0,
                T1
            >
            (
                in GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>
                inner,
                in Func<T, TKey0> outerKeySelector,
                in Func<T0, TKey0> innerKeySelector,
                in Func<T, T0, T1> resultSelector,
                Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TEqualityComparer1 : struct, IRefFunc<TKey2, TKey2, bool>
            where T2Selector : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey2, TEqualityComparer1>
                    >,
                T0>
            where T1 : unmanaged
            =>
            new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TEqualityComparer1>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >(this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TOuterEnumerable0,
                TOuterEnumerator0,
                TOuterSource0,
                TInnerEnumerable0,
                TInnerEnumerator0,
                TInnerSource0,
                TKey2,
                TOuterKeySelector0,
                TInnerKeySelector0,
                T0,
                T2Selector,
                TKeyEqualityComparer0,
                TKey0,
                T1
            >
            (
                in JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>
                inner,
                in Func<T, TKey0> outerKeySelector,
                in Func<T0, TKey0> innerKeySelector,
                in Func<T, T0, T1> resultSelector,
                Allocator allocator = Allocator.Temp
            )
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where T0 : unmanaged
            where TKey2 : unmanaged
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey2>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey2>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey2, TKey2, bool>
            where T2Selector : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            where T1 : unmanaged
            =>
            new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0,
                    TKey2, TOuterKeySelector0, TInnerKeySelector0, T0, T2Selector, TKeyEqualityComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TComparer0
            >
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
                , TAction0
            >
            (in RangeRepeatEnumerable<T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
            >
            (in RingBuffer<T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPrevSource0, TAction0
            >
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPrevSource0, TAction0
            >
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TKey0 : unmanaged
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, TPrevSource0, TAction0
            >
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where TPrevSource0 : unmanaged
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TKey0 : unmanaged
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
            >
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                T0, TKey0, T1
            >
            (in UnrolledLinkedList<T0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TKey0 : unmanaged



            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TPredicate0
            >
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged



            where TPredicate0 : struct, IWhereIndex<T0>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            Join<
                TEnumerable0, TEnumerator0, T0, TKey0, T1
                , TEnumerable1, TEnumerator1, T2, T3, TAction0
            >
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0> inner, in DelegateFuncToStructOperatorFunc<T, TKey0> outerKeySelector, in DelegateFuncToStructOperatorFunc<T0, TKey0> innerKeySelector, in Func<T, T0, T1> resultSelector, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where T3 : unmanaged
            where TAction0 : struct, IRefAction<T2, T3, T0>
            where TEnumerator0 : struct, IRefEnumerator<T2>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T2>
            where TKey0 : unmanaged



            where TEnumerator1 : struct, IRefEnumerator<T3>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T3>
            => new JoinEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T2, TEnumerable1, TEnumerator1, T3, T0, TAction0>.Enumerator,
                T0,
                TKey0,
                DelegateFuncToStructOperatorFunc<T, TKey0>,
                DelegateFuncToStructOperatorFunc<T0, TKey0>,
                T1,
                DelegateFuncToStructOperatorFunc<T, T0, T1>,
                DefaultEqualityComparer<TKey0>
            >
            (this, inner, outerKeySelector, innerKeySelector, resultSelector, default, allocator);
        #endregion

        #region Zip Function
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TEnumerable0 second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TEnumerable0,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in AppendEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TResult1>
            (in ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0, TResult1>
            (in DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TKey0, T0, TResult1>
            (in Grouping<TKey0, T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TKey0 : unmanaged
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<T, T2, TResult1>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult1>
            (in GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, Func<T, T2, TResult1> action, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, WhereIndexEnumerable<NativeEnumerable<T1>, NativeEnumerable<T1>.Enumerator, T1, GroupJoinPredicate<T1, TKey0, TEqualityComparer1>>, T2>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                GroupJoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<T, T2, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<T, T2, TResult1>
            >
            Zip<T2, TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TComparer0, TKey0, TKeySelector0, TKeySelector1, T0Selector, TEqualityComparer1, TResult1>
            (in JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>
            second, Func<T, T2, TResult1> action, T firstDefaultValue = default, T2 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where T1 : unmanaged
            where T2 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeySelector1 : struct, IRefFunc<T1, TKey0>
            where TEqualityComparer1 : struct, IRefFunc<TKey0, TKey0, bool>
            where T0Selector : struct, IRefFunc<T0, T1, T2>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>,
                JoinEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TKey0, TKeySelector0, TKeySelector1, T2, T0Selector, TEqualityComparer1>.Enumerator,
                T2,
                TResult1,
                DelegateFuncToAction<T, T2, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TComparer0, TResult1>
            (in OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in PrependEnumerable<TEnumerable0, TEnumerator0, T0>
                second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >(this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<T0, TAction0, TResult1>
            (in RangeRepeatEnumerable<T0, TAction0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in ReverseEnumerable<TEnumerable0, TEnumerator0, T0>
                second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<T0, TResult1>
            (in RingBuffer<T0>
                second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0, TResult1>
            (in SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TAction0, TResult1>
            (in SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevSource0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPrevSource0, TEnumerable1, TEnumerator1, TAction0, TResult1>
            (in SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where T0 : unmanaged
            where TAction0 : struct, IRefAction<TPrevSource0, TEnumerable1>
            where TPrevSource0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, TEnumerable1, TEnumerator1, TAction0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, TSetOperation0, T0, TResult1>
            (in SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>,
                SetOperationEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0, TSetOperation0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in SkipEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TakeEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TResult1>
            (in TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<T0, TResult1>
            (in UnrolledLinkedList<T0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where T0 : unmanaged
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TPredicate0, TResult1>
            (in WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>
            second, Func<T, T0, TResult1> action, T firstDefaultValue = default, T0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            where TResult1 : unmanaged
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                T0,
                TResult1,
                DelegateFuncToAction<T, T0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                TResult1,
                DelegateFuncToAction<T, TResult0, TResult1>
            >
            Zip<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0, TResult1>
            (in ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>
            second, Func<T, TResult0, TResult1> action, T firstDefaultValue = default, TResult0 secondDefaultValue = default, Allocator allocator = Allocator.Temp)
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where T0 : unmanaged
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T1>
            where TEnumerator1 : struct, IRefEnumerator<T1>
            where T1 : unmanaged
            where TResult0 : unmanaged
            where TResult1 : unmanaged
            where TAction0 : struct, IRefAction<T0, T1, TResult0>
            => new ZipEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>,
                ZipEnumerable<TEnumerable0, TEnumerator0, T0, TEnumerable1, TEnumerator1, T1, TResult0, TAction0>.Enumerator,
                TResult0,
                TResult1,
                DelegateFuncToAction<T, TResult0, TResult1>
            >
            (this, second, action, firstDefaultValue, secondDefaultValue, allocator);
        #endregion

        #region SelectMany
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                DelegateFuncToAction<T, NativeEnumerable<T0>>
            >
            SelectMany<T0>(Func<T, NativeEnumerable<T0>> func)
            where T0 : unmanaged
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                DelegateFuncToAction<T, NativeEnumerable<T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                NativeArrayToNativeEnumerableActionWrapper<T, T0>
            >
            SelectMany<T0>(Func<T, NativeArray<T0>> func)
            where T0 : unmanaged
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                NativeEnumerable<T0>,
                NativeEnumerable<T0>.Enumerator,
                NativeArrayToNativeEnumerableActionWrapper<T, T0>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                DelegateFuncToAction<T, ArrayEnumerable<T0>>
            >
            SelectMany<T0>(Func<T, ArrayEnumerable<T0>> func)
            where T0 : unmanaged
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                DelegateFuncToAction<T, ArrayEnumerable<T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                ArrayToArrayEnumerableActionWrapper<T, T0>
            >
            SelectMany<T0>(Func<T, T0[]> func)
            where T0 : unmanaged
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ArrayEnumerable<T0>,
                ArrayEnumerable<T0>.Enumerator,
                ArrayToArrayEnumerableActionWrapper<T, T0>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                DelegateFuncToAction<T, RingBuffer<T0>>
            >
            SelectMany<T0>(Func<T, RingBuffer<T0>> func)
            where T0 : unmanaged
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                RingBuffer<T0>,
                RingBuffer<T0>.Enumerator,
                DelegateFuncToAction<T, RingBuffer<T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                DelegateFuncToAction<T, UnrolledLinkedList<T0>>
            >
            SelectMany<T0>(Func<T, UnrolledLinkedList<T0>> func)
            where T0 : unmanaged
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                UnrolledLinkedList<T0>,
                UnrolledLinkedList<T0>.Enumerator,
                DelegateFuncToAction<T, UnrolledLinkedList<T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>,
                AppendEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, AppendEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                DelegateFuncToAction<T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1>(Func<T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEnumerator1 : struct, IRefEnumerator<T0>
            where TEnumerable1 : struct, IRefEnumerable<TEnumerator1, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>,
                ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>.Enumerator,
                DelegateFuncToAction<T, ConcatEnumerable<TEnumerable0, TEnumerator0, TEnumerable1, TEnumerator1, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>,
                DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, DefaultIfEmptyEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                DelegateFuncToAction<T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0, TEqualityComparer0, TGetHashCodeFunc0>(Func<T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TEqualityComparer0 : struct, IRefFunc<T0, T0, bool>
            where TGetHashCodeFunc0 : struct, IRefFunc<T0, int>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>,
                DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>.Enumerator,
                DelegateFuncToAction<T, DistinctEnumerable<TEnumerable0, TEnumerator0, T0, TEqualityComparer0, TGetHashCodeFunc0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey0, TElement0>,
                GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>,
                GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>.Enumerator,
                DelegateFuncToAction<T, GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>(Func<T, GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TElement0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TElementSelector0 : struct, IRefFunc<T0, TElement0>
            where TEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                Grouping<TKey0, TElement0>,
                GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>,
                GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>.Enumerator,
                DelegateFuncToAction<T, GroupByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TElement0, TElementSelector0, TEqualityComparer0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                DelegateFuncToAction<T, Grouping<TKey0, T0>>
            >
            SelectMany<T0, TKey0>(Func<T, Grouping<TKey0, T0>> func)
            where T0 : unmanaged
            where TKey0 : unmanaged
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                Grouping<TKey0, T0>,
                Grouping<TKey0, T0>.Enumerator,
                DelegateFuncToAction<T, Grouping<TKey0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>.Enumerator,
                DelegateFuncToAction<T, GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>>
            >
            SelectMany<T0, TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, TSelector0, TKeyEqualityComparer0>(Func<T, GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>> func)
            where T0 : unmanaged
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TSelector0 : struct,
            IRefFunc<TOuterSource0,
                WhereIndexEnumerable<
                    NativeEnumerable<TInnerSource0>,
                    NativeEnumerable<TInnerSource0>.Enumerator,
                    TInnerSource0,
                    GroupJoinPredicate<TInnerSource0, TKey0, TKeyEqualityComparer0>
                    >,
                T0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>,
                GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>.Enumerator,
                DelegateFuncToAction<T, GroupJoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>.Enumerator,
                DelegateFuncToAction<T, JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>>
            >
            SelectMany<T0, TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, TSelector0, TKeyEqualityComparer0>(
                Func<T,
                    JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>
                > func)
            where T0 : unmanaged
            where TOuterSource0 : unmanaged
            where TInnerSource0 : unmanaged
            where TOuterEnumerator0 : struct, IRefEnumerator<TOuterSource0>
            where TInnerEnumerator0 : struct, IRefEnumerator<TInnerSource0>
            where TOuterEnumerable0 : struct, IRefEnumerable<TOuterEnumerator0, TOuterSource0>
            where TInnerEnumerable0 : struct, IRefEnumerable<TInnerEnumerator0, TInnerSource0>
            where TKey0 : unmanaged
            where TOuterKeySelector0 : struct, IRefFunc<TOuterSource0, TKey0>
            where TInnerKeySelector0 : struct, IRefFunc<TInnerSource0, TKey0>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TSelector0 : struct, IRefFunc<TOuterSource0, TInnerSource0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>,
                JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>.Enumerator,
                DelegateFuncToAction<T, JoinEnumerable<TOuterEnumerable0, TOuterEnumerator0, TOuterSource0, TInnerEnumerable0, TInnerEnumerator0, TInnerSource0, TKey0, TOuterKeySelector0, TInnerKeySelector0, T0, TSelector0, TKeyEqualityComparer0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>,
                MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>.Enumerator,
                DelegateFuncToAction<T, MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>(Func<T, MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TKey0 : unmanaged
            where TKeySelector0 : struct, IRefFunc<T0, TKey0>
            where TKeyRenewPredicate0 : struct, IRefFunc<TKey0, TKey0, bool>
            where TKeyEqualityComparer0 : struct, IRefFunc<TKey0, TKey0, bool>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>,
                MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>.Enumerator,
                DelegateFuncToAction<T, MinMaxByEnumerable<TEnumerable0, TEnumerator0, T0, TKey0, TKeySelector0, TKeyRenewPredicate0, TKeyEqualityComparer0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                DelegateFuncToAction<T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0, TComparer0>(Func<T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TComparer0 : struct, IRefFunc<T0, T0, int>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>,
                OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>.Enumerator,
                DelegateFuncToAction<T, OrderByEnumerable<TEnumerable0, TEnumerator0, T0, TComparer0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>,
                PrependEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, PrependEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                DelegateFuncToAction<T, RangeRepeatEnumerable<T0, TAction0>>
            >
            SelectMany<T0, TAction0>(Func<T, RangeRepeatEnumerable<T0, TAction0>> func)
            where T0 : unmanaged
            where TAction0 : struct, IRangeRepeat<T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                RangeRepeatEnumerable<T0, TAction0>,
                RangeRepeatEnumerable<T0, TAction0>.Enumerator,
                DelegateFuncToAction<T, RangeRepeatEnumerable<T0, TAction0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>,
                ReverseEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, ReverseEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                DelegateFuncToAction<T, SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>>
            >
            SelectMany<T0, TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TAction0>(Func<T, SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>> func)
            where T0 : unmanaged
            where TPrevSource0 : unmanaged
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TAction0 : struct, IRefAction<TPrevSource0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>,
                SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                DelegateFuncToAction<T, SelectEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                DelegateFuncToAction<T, SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>>
            >
            SelectMany<T0, TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, TAction0>(Func<T, SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>> func)
            where T0 : unmanaged
            where TPrevSource0 : unmanaged
            where TAction0 : struct, ISelectIndex<TPrevSource0, T0>
            where TPrevEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, TPrevSource0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>,
                SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>.Enumerator,
                DelegateFuncToAction<T, SelectIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, TPrevSource0, T0, TAction0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, T0Enumerable, T0Enumerator, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, T0Enumerable, T0Enumerator, TAction0>.Enumerator,
                DelegateFuncToAction<T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, T0Enumerable, T0Enumerator, TAction0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0, TPrevSource0, T0Enumerable, T0Enumerator, TAction0>(Func<T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, T0Enumerable, T0Enumerator, TAction0>> func)
            where T0 : unmanaged
            where TPrevSource0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<TPrevSource0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, TPrevSource0>
            where T0Enumerator : struct, IRefEnumerator<T0>
            where T0Enumerable : struct, IRefEnumerable<T0Enumerator, T0>
            where TAction0 : struct, IRefAction<TPrevSource0, T0Enumerable>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, T0Enumerable, T0Enumerator, TAction0>,
                SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, T0Enumerable, T0Enumerator, TAction0>.Enumerator,
                DelegateFuncToAction<T, SelectManyEnumerable<TEnumerable0, TEnumerator0, TPrevSource0, T0, T0Enumerable, T0Enumerator, TAction0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                DelegateFuncToAction<T, SkipEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, SkipEnumerable<TEnumerable0, TEnumerator0, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SkipEnumerable<TEnumerable0, TEnumerator0, T0>,
                TEnumerator0,
                DelegateFuncToAction<T, SkipEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, SkipLastEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                DelegateFuncToAction<T, SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0, TPredicate0>(Func<T, SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TEnumerator0,
                DelegateFuncToAction<T, SkipWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, TakeEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, TakeEnumerable<TEnumerable0, TEnumerator0, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, TakeEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0>(Func<T, TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>,
                TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>.Enumerator,
                DelegateFuncToAction<T, TakeLastEnumerable<TEnumerable0, TEnumerator0, T0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                DelegateFuncToAction<T, TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>>
            >
            SelectMany<T0, TEnumerable0, TEnumerator0, TPredicate0>(Func<T, TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>> func)
            where T0 : unmanaged
            where TEnumerator0 : struct, IRefEnumerator<T0>
            where TEnumerable0 : struct, IRefEnumerable<TEnumerator0, T0>
            where TPredicate0 : struct, IRefFunc<T0, bool>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>,
                TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>.Enumerator,
                DelegateFuncToAction<T, TakeWhileEnumerable<TEnumerable0, TEnumerator0, T0, TPredicate0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>.Enumerator,
                DelegateFuncToAction<T, WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>>
            >
            SelectMany<T0, TPrevEnumerable0, TPrevEnumerator0, TPredicate0>(Func<T, WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>> func)
            where T0 : unmanaged
            where TPredicate0 : struct, IRefFunc<T0, bool>
            where TPrevEnumerator0 : struct, IRefEnumerator<T0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>,
                WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>.Enumerator,
                DelegateFuncToAction<T, WhereEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>.Enumerator,
                DelegateFuncToAction<T, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>>
            >
            SelectMany<T0, TPrevEnumerable0, TPrevEnumerator0, TPredicate0>(Func<T, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>> func)
            where T0 : unmanaged
            where TPredicate0 : struct, IWhereIndex<T0>
            where TPrevEnumerator0 : struct, IRefEnumerator<T0>
            where TPrevEnumerable0 : struct, IRefEnumerable<TPrevEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>,
                WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>.Enumerator,
                DelegateFuncToAction<T, WhereIndexEnumerable<TPrevEnumerable0, TPrevEnumerator0, T0, TPredicate0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirstSource0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>,
                ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirstSource0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>.Enumerator,
                DelegateFuncToAction<T, ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirstSource0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>>
            >
            SelectMany<T0, TFirstEnumerable0, TFirstEnumerator0, TFirstSource0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, TAction0>(Func<T, ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirstSource0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>> func)
            where T0 : unmanaged
            where TFirstSource0 : unmanaged
            where TSecondSource0 : unmanaged
            where TFirstEnumerator0 : struct, IRefEnumerator<TFirstSource0>
            where TFirstEnumerable0 : struct, IRefEnumerable<TFirstEnumerator0, TFirstSource0>
            where TSecondEnumerator0 : struct, IRefEnumerator<TSecondSource0>
            where TSecondEnumerable0 : struct, IRefEnumerable<TSecondEnumerator0, TSecondSource0>
            where TAction0 : struct, IRefAction<TFirstSource0, TSecondSource0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirstSource0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>,
                ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirstSource0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>.Enumerator,
                DelegateFuncToAction<T, ZipEnumerable<TFirstEnumerable0, TFirstEnumerator0, TFirstSource0, TSecondEnumerable0, TSecondEnumerator0, TSecondSource0, T0, TAction0>>
            >
            (this, func);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly
            SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>,
                SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>.Enumerator,
                DelegateFuncToAction<T, SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>>
            >
            SelectMany<T0, TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, TSetOperation0>(Func<T, SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>> func)
            where T0 : unmanaged
            where TFirstEnumerable0 : struct, IRefEnumerable<TFirstEnumerator0, T0>
            where TFirstEnumerator0 : struct, IRefEnumerator<T0>
            where TSecondEnumerable0 : struct, IRefEnumerable<TSecondEnumerator0, T0>
            where TSecondEnumerator0 : struct, IRefEnumerator<T0>
            where TSetOperation0 : struct, ISetOperation<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0>
            => new SelectManyEnumerable<
                RingBuffer<T>,
                Enumerator,
                T,
                T0,
                SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>,
                SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>.Enumerator,
                DelegateFuncToAction<T, SetOperationEnumerable<TFirstEnumerable0, TFirstEnumerator0, TSecondEnumerable0, TSecondEnumerator0, T0, TSetOperation0>>
            >
            (this, func);
        #endregion
    }
}
